settings
{
	main
	{
		Description: "Practice Field: Expanse is a tool for practicing against dummy bots. (Now with Custom AI for all heroes!)"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Data Center Preference: USA - Central
		Max Spectators: 4
		Max Team 2 Players: 0
		Return To Lobby: Never
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Workshop Expanse
			}
		}

		General
		{
			Game Mode Start: Immediately
			Hero Limit: Off
			Respawn Time Scalar: 0%
			Spawn Health Packs: Disabled
		}
	}

	heroes
	{
		Team 1
		{
			Mercy
			{
				Weapons Enabled: Caduceus Blaster Only
			}
		}

		General
		{
			Ultimate Generation: 200%

			Wrecking Ball
			{
				Jump Vertical Speed: 300%
			}
		}
	}
}

variables
{
	global:
		0: longRangeHeroes
		1: mediumRangeHeroes
		2: shortRangeHeroes
		3: veryShortRangeHeroes
		4: playerZoneRadiusDefault
		5: globalDifficulty
		6: playerBubbleRadius
		7: globalKillQuota
		8: projectileHeroes
		9: programmerName
		10: twitchURL
		11: longDistance
		12: mediumDistance
		13: shortDistance
		14: veryShortDistance
		15: githubURL
		17: moveDirStrafe
		19: moveDirForwardsNoStrafe
		20: moveDirBackwardsNoStrafe
		21: moveDirAll
		22: moveDirForwards
		23: moveDirBackwards
		24: version
		25: largePlayerZoneHeroes
		26: pseudoInfinity
		27: difficultyMax
		31: difficultyNames
		36: globalDifficultyName
		37: heroClassNames
		38: heroClasses
		41: globalHeroClass
		43: facingDefault_Head
		44: facingDefault_Body
		45: facingDefault_Position
		46: facingDefault_Other
		47: globalHealBot
		48: globalHealPlayer
		49: workshopCode

	player:
		0: player_InitSpawned
		1: player_Home
		2: player_1SecondCooldown_Enabled
		3: player_ZoneRadius
		4: currentKillNumber
		5: player_KillQuota
		6: player_CurrentHero
		7: player_Difficulty
		8: hud_Info
		9: inspireHeal_ID
		10: player_DeathPenalty_Enabled
		11: hud_Info_Enabled
		12: bot_OptimalDistanceDefault
		13: hud_i
		14: nextHero
		15: targetHelpIndicatorText
		16: player_Unkillable
		17: player_SelfHealAmount
		19: bot_AI_CanAim
		20: hud_Debug
		21: bot_Flicker_Enabled
		22: hud_Debug_Enabled
		23: bot_Facing_LookAtVector
		24: bot_isProjectile
		25: doomfistPunchDamage
		26: player_EnemyDistanceModifier
		27: player_EnemyDistanceMax
		28: hud_SkyMenu
		29: hud_SkyMenuArrowsVisibleTo
		30: bot_AI_MoveWASD_TimeMod
		31: bot_AI_MoveCrouch_TimeMod
		32: bot_AI_MoveJump_TimeMod
		33: index
		34: bot_FacingCapMin
		35: doomfistPunchCharge
		36: mccreeDeadeyeCharge
		37: mccreeDeadeyeRate
		38: mccreeDeadeyeUse
		39: bot_UltimateDisabled
		40: bot_ThrottleDir
		41: bot_FacingCapMax
		42: bot_AI_Enabled
		43: hud_SkyMenuVisibleTo
		44: hud_SkyMenu_Selection
		45: hud_SkyMenu_isOpen
		46: bot_AI_MoveWASD_Enabled
		47: bot_OptimalDistance
		48: bot_ViewAngleMod
		49: bot_AI_MoveCrouch_Enabled
		50: bot_AI_MoveJump_Enabled
		51: bot_AI_MoveCrouch_ChanceMod
		52: healing_Enabled
		53: bot_AI_MoveJump_ChanceMod
		54: index2
		55: bot_ProjectileSpeed
		56: bot_ProjectileSpeed_Secondary
		57: bot_ProjectileSpeed_Ability1
		58: inspireHeal_StartTime
		59: player_MysteryMode_Enabled
		60: player_CurrentHeroClass
		61: bot_AI_CanUseAbilities
		62: bot_AI_CanAttack
		63: bot_BotResetComplete
		64: bot_AI_HeroInitialized
		65: player_PlayerHero
		66: player_BotDistanceMin
		67: changingHero
		68: hud_MainFixed
		69: bot_ChanceMod
		70: player_DamageModDealt_ID
		71: player_DamageModReceived_ID
		72: bot_FacingPadMin
		73: bot_FacingPadMax
		74: bot_Facing_FlickPoint
		75: bot_ProjectileSpeed_Ability2
		76: bot_ProjectileSpeed_Ultimate
		77: bot_Facing_Other_Mod
		78: player_MirrorMode_Enabled
		79: bot_Facing_Base
		80: bot_FacingDefault
		81: bot_Throttle_StrafeDistanceMod
		82: bot_Hero_Ashe_DynamitePosition
		83: bot_Hero_Reinhardt_ChargePos
		84: player_CurrentHeroList
		85: player_DifficultyName
		86: bot_ProjectileSpeed_Primary
		87: player_CurrentHeroListName
		88: bot_FacingAngleModifier
		89: player_CurrentHeroIncrement
		90: bot_ReactionTime
		91: player_Effects
		92: hud_SkyMenuText
}

subroutines
{
	0: bot_SetHero
	2: botTeleport
	3: botReset
	5: bot_Crouch
	6: hud_SkyMenuToggle
	7: bot_Jump
	8: bot_Facing_FlickIn
	9: player_SetDifficulty
	10: bot_WASD
	11: bot_Facing_Body
	12: bot_Facing_Head
	13: bot_AIMode_Enable
	14: hud_InfoToggle
	15: bot_Facing_Position
	16: player_SetDistances
	19: skyMenuArrowVisibility
	20: player_1SecondCooldown
	21: bot_Facing_LookAt
	22: bot_Facing_FlickOut
	23: setHeroClass
	24: bot_Facing_Head_Projectile
	25: bot_Facing_Stop
	26: bot_Throttle_Stop
	27: bot_Facing_Reset
	28: bot_Facing_Other
	29: hud_DebugToggle
	30: bot_ReactionDelay
	31: player_MysteryMode
	32: hud_MainFixedToggle
}

rule("Info")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.version = Custom String("0.9-pre-release-beta.84");
		Global.workshopCode = Custom String("5DPKQ");
		Global.programmerName = Custom String("Snow#15707");
		Global.twitchURL = Custom String("twitch.tv/SnowwwLuna");
		Global.githubURL = Custom String("https://github.com/SnowRoberge/Practice-Field-Expanse");
	}
}

rule("Global Define")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.longDistance = 65;
		Global.mediumDistance = 50;
		Global.shortDistance = 35;
		Global.veryShortDistance = 20;
		Global.playerZoneRadiusDefault = 20;
		Global.playerBubbleRadius = 80;
		Global.difficultyNames = Empty Array;
		Global.difficultyNames[0] = Custom String("No AI Easy");
		Global.difficultyNames[1] = Custom String("No AI Medium");
		Global.difficultyNames[2] = Custom String("No AI Hard");
		Global.difficultyNames[3] = Custom String("AI Bronze");
		Global.difficultyNames[4] = Custom String("AI Silver");
		Global.difficultyNames[5] = Custom String("AI Gold");
		Global.difficultyNames[6] = Custom String("AI Platinum");
		Global.difficultyNames[7] = Custom String("AI Diamond");
		Global.difficultyNames[8] = Custom String("AI Master");
		Global.difficultyNames[9] = Custom String("AI Grandmaster");
		Global.difficultyNames[10] = Custom String("AI Top 500");
		Global.difficultyMax = 10;
		Global.heroClasses = Empty Array;
		Global.heroClasses[0] = All Heroes;
		Global.heroClasses[1] = All Tank Heroes;
		Global.heroClasses[2] = All Damage Heroes;
		Global.heroClasses[3] = All Support Heroes;
		Global.heroClassNames = Empty Array;
		Global.heroClassNames[0] = Custom String("All");
		Global.heroClassNames[1] = Custom String("Tank");
		Global.heroClassNames[2] = Custom String("Damage");
		Global.heroClassNames[3] = Custom String("Support");
		Global.facingDefault_Body = 0;
		Global.facingDefault_Head = 1;
		Global.facingDefault_Position = 2;
		Global.facingDefault_Other = 3;
		Global.pseudoInfinity = 999999;
	}
}

rule("Global Direction Array Define")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.moveDirAll = Empty Array;
		Modify Global Variable(moveDirAll, Append To Array, Forward);
		Modify Global Variable(moveDirAll, Append To Array, Left);
		Modify Global Variable(moveDirAll, Append To Array, Right);
		Modify Global Variable(moveDirAll, Append To Array, Backward);
		Modify Global Variable(moveDirAll, Append To Array, Vector(1, 0, 1));
		Modify Global Variable(moveDirAll, Append To Array, Vector(-1, 0, 1));
		Modify Global Variable(moveDirAll, Append To Array, Vector(1, 0, -1));
		Modify Global Variable(moveDirAll, Append To Array, Vector(-1, 0, -1));
		Global.moveDirForwards = Empty Array;
		Modify Global Variable(moveDirForwards, Append To Array, Forward);
		Modify Global Variable(moveDirForwards, Append To Array, Left);
		Modify Global Variable(moveDirForwards, Append To Array, Right);
		Modify Global Variable(moveDirForwards, Append To Array, Vector(1, 0, 1));
		Modify Global Variable(moveDirForwards, Append To Array, Vector(-1, 0, 1));
		Global.moveDirBackwards = Empty Array;
		Modify Global Variable(moveDirBackwards, Append To Array, Left);
		Modify Global Variable(moveDirBackwards, Append To Array, Right);
		Modify Global Variable(moveDirBackwards, Append To Array, Backward);
		Modify Global Variable(moveDirBackwards, Append To Array, Vector(1, 0, -1));
		Modify Global Variable(moveDirBackwards, Append To Array, Vector(-1, 0, -1));
		Global.moveDirForwardsNoStrafe = Empty Array;
		Modify Global Variable(moveDirForwardsNoStrafe, Append To Array, Forward);
		Modify Global Variable(moveDirForwardsNoStrafe, Append To Array, Vector(1, 0, 1));
		Modify Global Variable(moveDirForwardsNoStrafe, Append To Array, Vector(-1, 0, 1));
		Global.moveDirBackwardsNoStrafe = Empty Array;
		Modify Global Variable(moveDirBackwardsNoStrafe, Append To Array, Backward);
		Modify Global Variable(moveDirBackwardsNoStrafe, Append To Array, Vector(1, 0, -1));
		Modify Global Variable(moveDirBackwardsNoStrafe, Append To Array, Vector(-1, 0, -1));
		Global.moveDirStrafe = Empty Array;
		Modify Global Variable(moveDirStrafe, Append To Array, Left);
		Modify Global Variable(moveDirStrafe, Append To Array, Right);
	}
}

rule("Global Hero Define")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.longRangeHeroes = Empty Array;
		Modify Global Variable(longRangeHeroes, Append To Array, Hero(Widowmaker));
		Global.mediumRangeHeroes = Empty Array;
		Modify Global Variable(mediumRangeHeroes, Append To Array, Hero(Ana));
		Modify Global Variable(mediumRangeHeroes, Append To Array, Hero(Ashe));
		Modify Global Variable(mediumRangeHeroes, Append To Array, Hero(Baptiste));
		Modify Global Variable(mediumRangeHeroes, Append To Array, Hero(Hanzo));
		Global.shortRangeHeroes = Empty Array;
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(Bastion));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(LÃºcio));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(McCree));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(Mei));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(Orisa));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(Soldier: 76));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(TorbjÃ¶rn));
		Modify Global Variable(shortRangeHeroes, Append To Array, Hero(Zenyatta));
		Global.veryShortRangeHeroes = Empty Array;
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Brigitte));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(D.Va));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Moira));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Reaper));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Reinhardt));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Roadhog));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Sigma));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Symmetra));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Winston));
		Modify Global Variable(veryShortRangeHeroes, Append To Array, Hero(Zarya));
		Global.projectileHeroes = Empty Array;
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Ana));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Ashe));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Baptiste));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Bastion));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(D.Va));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Echo));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Genji));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Hanzo));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Junkrat));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(LÃºcio));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(McCree));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Mercy));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Orisa));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Pharah));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Reaper));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Roadhog));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Sigma));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Soldier: 76));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Sombra));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(TorbjÃ¶rn));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Tracer));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Widowmaker));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Wrecking Ball));
		Modify Global Variable(projectileHeroes, Append To Array, Hero(Zenyatta));
		Global.largePlayerZoneHeroes = Empty Array;
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Doomfist));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Echo));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Genji));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Junkrat));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Mercy));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Pharah));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Sombra));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Tracer));
		Modify Global Variable(largePlayerZoneHeroes, Append To Array, Hero(Wrecking Ball));
	}
}

rule("Global Settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.globalDifficulty = 6;
		Global.globalDifficultyName = Global.difficultyNames[Global.globalDifficulty];
		Global.globalHeroClass = 0;
		Global.globalKillQuota = 4;
		Global.globalHealBot = False;
		Global.globalHealPlayer = True;
		Disable Built-In Game Mode Completion;
	}
}

rule("Player Init")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Has Spawned(Event Player) == True;
		Event Player.player_InitSpawned == False;
	}

	actions
	{
		"Start Camera"
		Disable Hero HUD(Event Player);
		Start Camera(Event Player, Vector(0, 15, 0), Vector(0, 45, 0), 30);
		"Initialize Variables"
		Event Player.currentKillNumber = 0;
		Event Player.player_CurrentHero = 0;
		Event Player.player_CurrentHeroClass = Global.globalHeroClass;
		Event Player.player_CurrentHeroIncrement = 0;
		Call Subroutine(setHeroClass);
		Event Player.hud_Info_Enabled = False;
		Event Player.healing_Enabled = Global.globalHealPlayer;
		Event Player.player_1SecondCooldown_Enabled = False;
		Event Player.player_DeathPenalty_Enabled = False;
		Event Player.player_MirrorMode_Enabled = False;
		Event Player.player_KillQuota = Global.globalKillQuota;
		Event Player.player_Difficulty = Global.globalDifficulty;
		Event Player.player_DifficultyName = Global.globalDifficultyName;
		Event Player.player_ZoneRadius = Global.playerZoneRadiusDefault;
		Event Player.player_PlayerHero = Hero Of(Event Player);
		Call Subroutine(player_SetDistances);
		"HUD Object Arrays"
		Event Player.hud_Info = Empty Array;
		Event Player.hud_Debug = Empty Array;
		Event Player.hud_SkyMenuText = Empty Array;
		"Set Home Vector"
		If(Slot Of(Event Player) == 0);
			Event Player.player_Home = Vector(-380 + Global.playerBubbleRadius, 0, 380 - Global.playerBubbleRadius);
		Else If(Slot Of(Event Player) == 1);
			Event Player.player_Home = Vector(380 - Global.playerBubbleRadius, 0, -380 + Global.playerBubbleRadius);
		Else If(Slot Of(Event Player) == 2);
			Event Player.player_Home = Vector(380 - Global.playerBubbleRadius, 0, 380 - Global.playerBubbleRadius);
		Else If(Slot Of(Event Player) == 3);
			Event Player.player_Home = Vector(-380 + Global.playerBubbleRadius, 0, -380 + Global.playerBubbleRadius);
		Else If(Slot Of(Event Player) == 4);
			Event Player.player_Home = Vector(0, 0, 380 - Global.playerBubbleRadius);
		Else If(Slot Of(Event Player) == 5);
			Event Player.player_Home = Vector(0, 0, -380 + Global.playerBubbleRadius);
		End;
		Event Player.player_Effects = Empty Array;
		"Create Player Movement Zone"
		Create Effect(All Players(All Teams), Ring, White, Event Player.player_Home, Event Player.player_ZoneRadius + 1.250,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, player_Effects, Append To Array, Last Created Entity);
		"Create Maximum Enemy Distance Zone"
		Create Effect(All Players(All Teams), Light Shaft, White, Event Player.player_Home, Event Player.player_EnemyDistanceMax + 1.250,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, player_Effects, Append To Array, Last Created Entity);
		"Disable Skirmish HUD"
		Disable Game Mode HUD(Event Player);
		Call Subroutine(hud_MainFixedToggle);
		"Show info"
		Start Rule(hud_InfoToggle, Restart Rule);
		"Start Facing Bot Until It Inits"
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player),
			Team 2))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Players In Slot(Slot Of(Event Player), Team 2)))) * 10, To World, Direction and Turn Rate);
		"Intro tip"
		Small Message(Event Player, Custom String("Open menu for options"));
		Wait(1, Ignore Condition);
		Small Message(Event Player, Custom String("Attack enemy bot to begin"));
		Wait(1, Ignore Condition);
		"Preload Heroes"
		For Player Variable(Event Player, index, 0, Count Of(All Heroes), 1);
			Preload Hero(Event Player, All Heroes[Event Player.index]);
			Wait(1 / 60, Ignore Condition);
		End;
		"Teleport Player Home And Reset HUD"
		Teleport(Event Player, Event Player.player_Home);
		Stop Camera(Event Player);
		Enable Hero HUD(Event Player);
		"Player initialization is complete"
		Event Player.player_InitSpawned = True;
	}
}

rule("Bot Init")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_InitSpawned == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_SetHero);
		Disable Built-In Game Mode Respawning(Players In Slot(Slot Of(Event Player), Team 2));
		"Setup difficulty"
		Call Subroutine(player_SetDifficulty);
		Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled = Global.globalHealBot;
		"Face enemy bot after it is created"
		Wait(12 / 60, Ignore Condition);
		Stop Facing(Event Player);
	}
}

rule("Player Leave Destroy All Objects")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Entity Exists(Players In Slot(Slot Of(Event Player), Team 1)) == False;
		Is In Spawn Room(Players In Slot(Slot Of(Event Player), Team 1)) == False;
		Has Spawned(Players In Slot(Slot Of(Event Player), Team 1)) == False;
	}

	actions
	{
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText) > 0);
			Call Subroutine(hud_SkyMenuToggle);
		End;
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
			Call Subroutine(hud_DebugToggle);
		End;
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
			Call Subroutine(hud_InfoToggle);
		End;
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed) > 0);
			Call Subroutine(hud_MainFixedToggle);
		End;
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).player_Effects) > 0);
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), index, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
				.player_Effects), -1, -1);
				Destroy Effect(Players In Slot(Slot Of(Event Player), Team 1).player_Effects[Players In Slot(Slot Of(Event Player), Team 1)
					.index]);
				Players In Slot(Slot Of(Event Player), Team 1).player_Effects = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
					.player_Effects, Players In Slot(Slot Of(Event Player), Team 1).player_Effects[Players In Slot(Slot Of(Event Player), Team 1)
					.index]);
			End;
		End;
		Destroy Dummy Bot(Team 2, Slot Of(Event Player));
	}
}

rule("Bot Respawn")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber < Players In Slot(Slot Of(Event Player), Team 1).player_KillQuota;
	}

	actions
	{
		Event Player.bot_AI_HeroInitialized = False;
		Stop Heal Over Time(Event Player.inspireHeal_ID);
		Wait(0.250, Abort When False);
		Call Subroutine(botTeleport);
		Resurrect(Event Player);
	}
}

rule("Bot Elimination")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Event Player.currentKillNumber += 1;
		If(Players In Slot(Slot Of(Event Player), Team 1).player_DeathPenalty_Enabled == True && Players In Slot(Slot Of(Event Player),
			Team 1).currentKillNumber > 0);
			Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber -= 1;
		End;
	}
}

rule("Bot BM")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		If(Random Real(0, 1) < 0.600);
			Event Player.index2 = Random Integer(1, 4);
			Wait(Random Real(0.650, 1.150), Ignore Condition);
			If(Event Player.index2 == 1);
				Communicate(Event Player, Hello);
			Else If(Event Player.index2 == 2);
				Communicate(Event Player, Thanks);
			Else If(Event Player.index2 == 3);
				Communicate(Event Player, Sorry);
			Else If(Event Player.index2 == 4);
				Communicate(Event Player, Goodbye);
			End;
		End;
	}
}

rule("Bot Hello")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Communicating(Event Player, Hello) == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
	}

	actions
	{
		Wait(Random Real(1, 1.250), Ignore Condition);
		Communicate(Players In Slot(Slot Of(Event Player), Team 2), Hello);
	}
}

rule("Bot You Are Welcome")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Communicating(Event Player, Thanks) == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
	}

	actions
	{
		Wait(Random Real(1, 1.250), Ignore Condition);
		Communicate(Players In Slot(Slot Of(Event Player), Team 2), You are Welcome);
	}
}

rule("Bot Asleep Thanks")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Ana;
	}

	conditions
	{
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
		Has Status(Players In Slot(Slot Of(Event Player), Team 2), Asleep) == True;
	}

	actions
	{
		If(Random Real(0, 1) < 0.750);
			Wait(Random Real(0.750, 1), Ignore Condition);
			Communicate(Players In Slot(Slot Of(Event Player), Team 2), Thanks);
		End;
	}
}

rule("Increment Kills")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 2) == Victim;
	}

	actions
	{
		Event Player.currentKillNumber += 1;
	}
}

rule("Next Hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Event Player.currentKillNumber == Event Player.player_KillQuota;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.player_CurrentHeroIncrement = 1;
		Call Subroutine(bot_SetHero);
	}
}

rule("Player Elimination Heal")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Health(Event Player) != Max Health(Event Player);
		Event Player.healing_Enabled == True;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Start Heal Over Time(Event Player, Null, Random Real(Event Player.player_Difficulty / 5, Event Player.player_Difficulty / 2.500),
			55);
	}
}

rule("Player/Bot Inspire Heal")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.healing_Enabled == True;
		Total Time Elapsed >= Event Player.inspireHeal_StartTime + 1;
		Event Damage > 5;
	}

	actions
	{
		"Essentially Brigitte's Inspire"
		If(Event Player.inspireHeal_ID != 0);
			Stop Heal Over Time(Event Player.inspireHeal_ID);
		End;
		Start Heal Over Time(Event Player, Null, 6, 15);
		Event Player.inspireHeal_ID = Last Heal Over Time ID;
		Event Player.inspireHeal_StartTime = Total Time Elapsed;
	}
}

rule("Reset Player At Home")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))),
			Event Player.player_Home) > Event Player.player_ZoneRadius;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Event Player.player_InitSpawned == True;
	}

	actions
	{
		"Stun if in air to prevent infinite teleport loop"
		If(((Hero Of(Event Player) == Hero(Widowmaker) && Is Using Ability 1(Event Player)) || (Hero Of(Event Player) == Hero(Doomfist)
			&& Is Using Ability 2(Event Player))) == True);
			Cancel Primary Action(Event Player);
		End;
		Play Effect(Event Player, Debuff Impact Sound, White, Event Player, 75);
		Play Effect(Event Player, Bad Pickup Effect, White, Event Player.player_Home, 1);
		If(Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 2), 20) == True);
			Teleport(Event Player, Event Player.player_Home);
			Wait(1 / 60, Ignore Condition);
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
				Players In Slot(Slot Of(Event Player), Team 2)))) * 5, To World, None);
			Wait(0.200, Ignore Condition);
			Stop Facing(Event Player);
		Else;
			Teleport(Event Player, Event Player.player_Home);
		End;
		Allow Button(Event Player, Jump);
	}
}

rule("Reset Enemy Position Non AI Difficulty")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(
			Event Player), Team 1).player_EnemyDistanceMax - 1;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
	}

	actions
	{
		"Flip 180"
		Stop Facing(Event Player);
		Wait(2 / 60, Ignore Condition);
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player) + World Vector Of(Vector(0, 0,
			-5), Event Player, Rotation)), Random Integer(300, 500), To Player, None);
	}
}

rule("Player Set Distances")
{
	event
	{
		Subroutine;
		player_SetDistances;
	}

	actions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius = Global.playerZoneRadiusDefault;
		If(Array Contains(Global.longRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
			Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax = Global.longDistance;
		Else If(Array Contains(Global.mediumRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
			Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax = Global.mediumDistance;
		Else If(Array Contains(Global.shortRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
			Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax = Global.shortDistance;
		Else If(Array Contains(Global.largePlayerZoneHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
			Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax = Global.shortDistance;
			Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius = Players In Slot(Slot Of(Event Player), Team 1)
				.player_EnemyDistanceMax;
		Else If(Array Contains(Global.veryShortRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
			Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax = Global.veryShortDistance;
			Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius = Players In Slot(Slot Of(Event Player), Team 1)
				.player_EnemyDistanceMax;
		End;
	}
}

rule("Player Change Self Hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Crouch) == True;
		Is Button Held(Event Player, Reload) == True;
		Event Player.changingHero == False;
		Players In Slot(Slot Of(Event Player), Team 2).changingHero == False;
		Event Player.player_InitSpawned == True;
	}

	actions
	{
		Wait(15 / 60, Abort When False);
		If(Event Player.player_MirrorMode_Enabled == True);
			Small Message(Event Player, Custom String("Cannot change heroes while Mirror Mode is on"));
			Abort;
		End;
		Small Message(Event Player, Custom String("Continue holding {0} and {1} to change heroes", Input Binding String(Button(Crouch)),
			Input Binding String(Button(Reload))));
		Set Status(Event Player, Null, Phased Out, 1);
		Wait(15 / 60, Abort When False);
		Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
		Event Player.changingHero = True;
		Wait(1, Ignore Condition);
		Reset Player Hero Availability(Event Player);
	}
}

rule("Player Self Hero Change Teleport Enemy On Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is In Spawn Room(Event Player) == False;
		Has Spawned(Event Player) == True;
		Event Player.changingHero == True;
		Players In Slot(Slot Of(Event Player), Team 2).changingHero == False;
	}

	actions
	{
		Wait(6 / 60, Abort When False);
		Call Subroutine(player_SetDistances);
		Call Subroutine(botTeleport);
		Event Player.changingHero = False;
	}
}

rule("Player Change Bot Hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Is Button Held(Event Player, Reload) == True;
		Players In Slot(Slot Of(Event Player), Team 2).changingHero == False;
		Event Player.changingHero == False;
		Event Player.player_InitSpawned == True;
	}

	actions
	{
		Wait(15 / 60, Abort When False);
		Small Message(Event Player, Custom String("Continue holding {0} and {1} to change heroes", Input Binding String(Button(Interact)),
			Input Binding String(Button(Reload))));
		Set Status(Event Player, Null, Phased Out, 1);
		Wait(15 / 60, Abort When False);
		Event Player.player_PlayerHero = Hero Of(Event Player);
		Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
		Players In Slot(Slot Of(Event Player), Team 2).changingHero = True;
		Wait(1, Ignore Condition);
		Reset Player Hero Availability(Event Player);
	}
}

rule("Player Change Bot Hero On Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is In Spawn Room(Event Player) == False;
		Has Spawned(Event Player) == True;
		Event Player.changingHero == False;
		Players In Slot(Slot Of(Event Player), Team 2).changingHero == True;
	}

	actions
	{
		Wait(9 / 60, Abort When False);
		If(Event Player.player_CurrentHeroClass != 0);
			Event Player.player_CurrentHeroClass = 0;
			Call Subroutine(setHeroClass);
		End;
		Event Player.player_CurrentHero = Index Of Array Value(Event Player.player_CurrentHeroList, Hero Of(Event Player));
		Start Forcing Player To Be Hero(Event Player, Event Player.player_PlayerHero);
		Wait(1 / 60, Ignore Condition);
		Stop Forcing Player To Be Hero(Event Player);
		Call Subroutine(bot_SetHero);
		Players In Slot(Slot Of(Event Player), Team 2).changingHero = False;
	}
}

rule("Subroutine: botTeleport")
{
	event
	{
		Subroutine;
		botTeleport;
	}

	actions
	{
		Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 2));
		Wait(6 / 60, Ignore Condition);
		Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), All);
		Wait(1 / 60, Ignore Condition);
		Set Facing(Players In Slot(Slot Of(Event Player), Team 2), Vector(Random Real(-1, 1), Random Real(-0.500, 0.500), Random Real(-1,
			1)), To Player);
		Wait(1 / 60, Ignore Condition);
		Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceModifier = Players In Slot(Slot Of(Event Player), Team 1)
			.player_EnemyDistanceMax / Players In Slot(Slot Of(Event Player), Team 1).player_KillQuota * 2;
		Wait(1 / 60, Ignore Condition);
		If(Players In Slot(Slot Of(Event Player), Team 1).player_KillQuota != 1 && Players In Slot(Slot Of(Event Player), Team 1)
			.player_KillQuota != Global.pseudoInfinity);
			Players In Slot(Slot Of(Event Player), Team 1).player_BotDistanceMin = (Players In Slot(Slot Of(Event Player), Team 1)
				.player_KillQuota - 1 - Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber) % (Players In Slot(Slot Of(
				Event Player), Team 1).player_KillQuota / 2) * Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceModifier;
			Teleport(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Random Integer(1, 360), 0) * Random Integer(
				Players In Slot(Slot Of(Event Player), Team 1).player_BotDistanceMin, Players In Slot(Slot Of(Event Player), Team 1)
				.player_BotDistanceMin + Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceModifier) + Players In Slot(
				Slot Of(Event Player), Team 1).player_Home);
		Else;
			Teleport(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Random Integer(1, 360), 0) * Random Real(0,
				Players In Slot(Slot Of(Event Player), Team 1).player_EnemyDistanceMax) + Players In Slot(Slot Of(Event Player), Team 1)
				.player_Home);
		End;
		Wait(6 / 60, Ignore Condition);
		Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Buff Impact Sound, White, Players In Slot(Slot Of(Event Player),
			Team 2), 180);
		Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Bad Pickup Effect, White, Players In Slot(Slot Of(Event Player),
			Team 2), 1);
		Wait(1 / 60, Ignore Condition);
		Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), None);
	}
}

rule("Subroutine: botReset")
{
	event
	{
		Subroutine;
		botReset;
	}

	actions
	{
		Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete = False;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_HeroInitialized = False;
		"Disable AI Mode"
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_Enabled == True);
			Players In Slot(Slot Of(Event Player), Team 2).bot_AI_Enabled = False;
			Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveWASD_Enabled = False;
			Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_Enabled = False;
			Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_Enabled = False;
			Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim = False;
			Players In Slot(Slot Of(Event Player), Team 2).bot_Throttle_StrafeDistanceMod = 5;
			Skip If(Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3, 1);
		End;
		"Cancel Current Abilities and Disable Buttons"
		Cancel Primary Action(Players In Slot(Slot Of(Event Player), Team 2));
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Primary Fire);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Secondary Fire);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 1);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 2);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Ultimate);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Melee);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Reload);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Primary Fire);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Secondary Fire);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 1);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 2);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Ultimate);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Melee);
		Disallow Button(Players In Slot(Slot Of(Event Player), Team 2), Reload);
		"Stop facing and throttle"
		Call Subroutine(bot_Throttle_Stop);
		Call Subroutine(bot_Facing_Stop);
		"Force to be current hero or create dummy bot"
		If(Hero Of(Players In Slot(Slot Of(Event Player), Team 2)) != Players In Slot(Slot Of(Event Player), Team 1)
			.player_CurrentHeroList[Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero]);
			If(Entity Exists(Players In Slot(Slot Of(Event Player), Team 2)));
				Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), All);
				Start Forcing Player To Be Hero(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)
					.player_CurrentHeroList[Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero]);
			Else;
				Create Dummy Bot(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroList[Players In Slot(Slot Of(Event Player),
					Team 1).player_CurrentHero], Team 2, Slot Of(Event Player), Vector(0, 0, 0), Vector(0, 0, 0));
				Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), All);
				If(Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty >= 3);
					Players In Slot(Slot Of(Event Player), Team 2).bot_Throttle_StrafeDistanceMod = 5;
				End;
			End;
			"Wait a frame after changing hero or creating bot"
			Wait(1 / 60, Ignore Condition);
			Small Message(Players In Slot(Slot Of(Event Player), Team 1), Custom String("{0}  {1}!", Hero Icon String(Hero Of(Players In Slot(
				Slot Of(Event Player), Team 2))), Hero Of(Players In Slot(Slot Of(Event Player), Team 2))));
		Else;
		End;
		"Set Unkillable"
		Skip If(Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3, 1);
		Set Status(Players In Slot(Slot Of(Event Player), Team 2), Null, Unkillable, 9999);
		"Enable Buttons"
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Primary Fire);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Secondary Fire);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 1);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Ability 2);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Ultimate);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Melee);
		Allow Button(Players In Slot(Slot Of(Event Player), Team 2), Reload);
		Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete = True;
	}
}

rule("Subroutine: bot_SetHero")
{
	event
	{
		Subroutine;
		bot_SetHero;
	}

	actions
	{
		If(Health(Players In Slot(Slot Of(Event Player), Team 1)) != Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
			Heal(Players In Slot(Slot Of(Event Player), Team 1), Null, Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
		End;
		Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber = 0;
		Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber = 0;
		If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroIncrement == 1);
			If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero == Count Of(Event Player.player_CurrentHeroList) - 1);
				Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero = 0;
			Else;
				Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero = Players In Slot(Slot Of(Event Player), Team 1).nextHero;
			End;
		Else If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroIncrement == -1);
			If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero == 0);
				Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero = Count Of(Players In Slot(Slot Of(Event Player), Team 1)
					.player_CurrentHeroList) - 1;
			Else;
				Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero -= 1;
			End;
		Else;
		End;
		If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero == Count Of(Players In Slot(Slot Of(Event Player), Team 1)
			.player_CurrentHeroList) - 1);
			Players In Slot(Slot Of(Event Player), Team 1).nextHero = 0;
		Else;
			Players In Slot(Slot Of(Event Player), Team 1).nextHero = Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHero + 1;
		End;
		Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroIncrement = 0;
		Call Subroutine(botReset);
		Call Subroutine(botTeleport);
	}
}

rule("Disable Primary Secondary Skip")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Primary Fire);
		Disallow Button(Event Player, Secondary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Allow Button(Event Player, Primary Fire);
		Allow Button(Event Player, Secondary Fire);
	}
}

rule("Skip Hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		(Is Button Held(Event Player, Primary Fire) == True || Is Button Held(Event Player, Secondary Fire) == True) == True;
	}

	actions
	{
		If(Is Button Held(Event Player, Primary Fire) == True);
			Event Player.player_CurrentHeroIncrement = 1;
		Else;
			Event Player.player_CurrentHeroIncrement = -1;
		End;
		Call Subroutine(bot_SetHero);
	}
}

rule("Special Rule: Doomfist Rocket Punch Start")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.doomfistPunchCharge = Total Time Elapsed;
		Event Player.doomfistPunchDamage = 0;
	}
}

rule("Special Rule: Doomfist Rocket Punch Stop")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Is Alive(Event Player) == True;
		Event Player.doomfistPunchCharge != 0;
	}

	actions
	{
		Event Player.doomfistPunchDamage = (Total Time Elapsed - Event Player.doomfistPunchCharge) / 1.400 * 100.750 + 49.250;
		If(Event Player.doomfistPunchDamage > 150);
			Event Player.doomfistPunchDamage = 150;
		End;
	}
}

rule("Special Rule: Doomfist Rocket Punch Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) == True;
		Distance Between(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Players In Slot(Slot Of(
			Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius - 2.500;
	}

	actions
	{
		Apply Impulse(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Direction Towards(Players In Slot(
			Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player), 1, To World, Cancel Contrary Motion);
		Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player,
			Event Player.doomfistPunchDamage);
		Event Player.doomfistPunchCharge = 0;
		Event Player.doomfistPunchDamage = 0;
	}
}

rule("Info Toggle")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Is Button Held(Event Player, Crouch) == True;
	}

	actions
	{
		Start Rule(hud_InfoToggle, Restart Rule);
	}
}

rule("Target Help Indicator")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), 90) == False;
		Event Player.player_Difficulty <= 2;
		Y Component Of(Facing Direction Of(Event Player)) <= 0.500;
	}

	actions
	{
		Wait(4, Abort When False);
		Play Effect(Event Player, Debuff Impact Sound, White, Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(
			Event Player))), 200);
		Big Message(Event Player, Custom String("Turn Around!"));
		Create In-World Text(Event Player, Custom String("TARGET!"), Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(
			Event Player))), 4, Do Not Clip, Visible To Position and String, Yellow, Default Visibility);
		Event Player.targetHelpIndicatorText = Last Text ID;
		Wait(3, Ignore Condition);
		Destroy In-World Text(Event Player.targetHelpIndicatorText);
		Loop If Condition Is True;
	}
}

rule("Subroutine: hud_SkyMenuToggle")
{
	event
	{
		Subroutine;
		hud_SkyMenuToggle;
	}

	actions
	{
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
			Call Subroutine(hud_InfoToggle);
		Else If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
			Call Subroutine(hud_DebugToggle);
		End;
		Wait(3 / 60, Ignore Condition);
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText) > 0);
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
				.hud_SkyMenuText), -1, -1);
				Destroy In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText[Players In Slot(Slot Of(Event Player), Team 1)
					.hud_i]);
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
					.hud_SkyMenuText, Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText[Players In Slot(Slot Of(Event Player), Team 1)
					.hud_i]);
			End;
			Clear Status(Players In Slot(Slot Of(Event Player), Team 1), Phased Out);
			Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 1));
			Stop Facing(Players In Slot(Slot Of(Event Player), Team 1));
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Primary Fire);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Secondary Fire);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Ability 1);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Ability 2);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Ultimate);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Reload);
			Allow Button(Players In Slot(Slot Of(Event Player), Team 1), Melee);
			Wait(6 / 60, Ignore Condition);
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_isOpen = False;
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo = Null;
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[0] = Null;
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[1] = Null;
			Stop Camera(Players In Slot(Slot Of(Event Player), Team 1));
			Enable Hero HUD(Players In Slot(Slot Of(Event Player), Team 1));
			If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroListName != Global.heroClassNames[Players In Slot(Slot Of(
				Event Player), Team 1).player_CurrentHeroClass]);
				Event Player.player_CurrentHero = 0;
				Event Player.player_CurrentHeroIncrement = 0;
				Call Subroutine(setHeroClass);
				Call Subroutine(bot_SetHero);
			Else;
				Call Subroutine(botTeleport);
			End;
		Else;
			If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_Enabled == True);
				Call Subroutine(botReset);
			End;
			Set Status(Players In Slot(Slot Of(Event Player), Team 1), Null, Phased Out, 9999);
			Start Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
				.player_Home, False);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 1), Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 1)),
				100, To World, Direction and Turn Rate);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Primary Fire);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Secondary Fire);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Ability 1);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Ability 2);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Ultimate);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Reload);
			Disallow Button(Players In Slot(Slot Of(Event Player), Team 1), Melee);
			Heal(Players In Slot(Slot Of(Event Player), Team 1), Null, Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
			Start Camera(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
				.hud_SkyMenu_Selection - Vector(0, 15, 0), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_Selection, 30);
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo = Players In Slot(Slot Of(Event Player), Team 1);
			Call Subroutine(skyMenuArrowVisibility);
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_isOpen = True;
			Disable Hero HUD(Players In Slot(Slot Of(Event Player), Team 1));
			Big Message(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Use WASD to navigate the menu."));
			"Generate Menu"
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu = Empty Array;
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, -1, 11, 1);
				Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Players In Slot(Slot Of(
					Event Player), Team 1).player_Home + Vector(0, 45, 1.250 * Players In Slot(Slot Of(Event Player), Team 1).hud_i));
			End;
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_Selection = Players In Slot(Slot Of(Event Player), Team 1)
				.hud_SkyMenu[0];
			"Menu Selection Arrows"
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo = Empty Array;
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuArrowsVisibleTo, Append To Array, Null);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuArrowsVisibleTo, Append To Array, Null);
			Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText = Empty Array;
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[0], Icon String(Arrow: Left),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_Selection + Vector(4, 0, 0), 1.500, Clip Against Surfaces,
				Visible To Position and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[1], Icon String(Arrow: Right),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_Selection + Vector(-4, 0, 0), 1.500, Clip Against Surfaces,
				Visible To Position and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			"Menu Text"
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Difficulty: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_DifficultyName), Players In Slot(Slot Of(Event Player), Team 1)
				.hud_SkyMenu[0], 1.500, Clip Against Surfaces, Visible To and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Kill Quota: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_KillQuota == Global.pseudoInfinity ? Custom String("Infinite")
				: Players In Slot(Slot Of(Event Player), Team 1).player_KillQuota), Players In Slot(Slot Of(Event Player), Team 1)
				.hud_SkyMenu[1], 1.500, Clip Against Surfaces, Visible To and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Hero Type: {0}",
				Global.heroClassNames[Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroClass]), Players In Slot(Slot Of(
				Event Player), Team 1).hud_SkyMenu[2], 1.500, Clip Against Surfaces, Visible To and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String(
				"Rapid Fire Mystery Mode: {0}", Players In Slot(Slot Of(Event Player), Team 1)
				.player_MysteryMode_Enabled == True ? Custom String("On") : Custom String("Off")), Players In Slot(Slot Of(Event Player),
				Team 1).hud_SkyMenu[3], 1.500, Clip Against Surfaces, Visible To and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Mirror Mode: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_MirrorMode_Enabled == True ? Custom String("On") : Custom String("Off")),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[4], 1.500, Clip Against Surfaces, Visible To and String, White,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("1 Sec Cooldown Mode: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_1SecondCooldown_Enabled == True ? Custom String("On") : Custom String(
				"Off")), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[5], 1.500, Clip Against Surfaces, Visible To and String,
				White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("-1 Kill On Death: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_DeathPenalty_Enabled == True ? Custom String("On") : Custom String(
				"Off")), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[6], 1.500, Clip Against Surfaces, Visible To and String,
				White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Player Healing: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).healing_Enabled == True ? Custom String("On") : Custom String("Off")),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[7], 1.500, Clip Against Surfaces, Visible To and String, White,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Bot Healing: {0}",
				Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled == True ? Custom String("On") : Custom String("Off")),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[8], 1.500, Clip Against Surfaces, Visible To and String, White,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Player Unkillable: {0}",
				Players In Slot(Slot Of(Event Player), Team 1).player_Unkillable == True ? Custom String("On") : Custom String("Off")),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[9], 1.500, Clip Against Surfaces, Visible To and String, White,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String(
				"Disable Bot Ultimate: {0}", Players In Slot(Slot Of(Event Player), Team 2).bot_UltimateDisabled == True ? Custom String("On")
				: Custom String("Off")), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[10], 1.500, Clip Against Surfaces,
				Visible To and String, White, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Custom String("Bot Flicker: {0}",
				Players In Slot(Slot Of(Event Player), Team 2).bot_Flicker_Enabled == True ? Custom String("On") : Custom String("Off")),
				Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[11], 1.500, Clip Against Surfaces, Visible To and String, White,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuText, Append To Array, Last Text ID);
			Call Subroutine(skyMenuArrowVisibility);
		End;
		Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Explosion Sound, White, Players In Slot(Slot Of(Event Player), Team 1),
			45);
	}
}

rule("Player Sky Menu Toggle")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Melee) == True;
		Is Button Held(Event Player, Reload) == True;
        Event Player.player_InitSpawned == True;
	}

	actions
	{
		Wait(6 / 60, Abort When False);
		Call Subroutine(hud_SkyMenuToggle);
	}
}

rule("Player Sky Menu Move Selection Up")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.hud_SkyMenu_isOpen == True;
		Throttle Of(Event Player) == Forward;
	}

	actions
	{
		Play Effect(Event Player, Explosion Sound, White, Event Player, 15);
		If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[0]);
			Event Player.hud_SkyMenu_Selection = Event Player.hud_SkyMenu[Count Of(Event Player.hud_SkyMenu) - 1];
		Else;
			Event Player.hud_SkyMenu_Selection = Event Player.hud_SkyMenu[Index Of Array Value(Event Player.hud_SkyMenu,
				Event Player.hud_SkyMenu_Selection) - 1];
		End;
		Call Subroutine(skyMenuArrowVisibility);
	}
}

rule("Player Sky Menu Move Selection Down")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.hud_SkyMenu_isOpen == True;
		Throttle Of(Event Player) == Backward;
	}

	actions
	{
		Play Effect(Event Player, Explosion Sound, White, Event Player, 15);
		If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[Count Of(Event Player.hud_SkyMenu) - 1]);
			Event Player.hud_SkyMenu_Selection = Event Player.hud_SkyMenu[0];
		Else;
			Event Player.hud_SkyMenu_Selection = Event Player.hud_SkyMenu[Index Of Array Value(Event Player.hud_SkyMenu,
				Event Player.hud_SkyMenu_Selection) + 1];
		End;
		Call Subroutine(skyMenuArrowVisibility);
	}
}

rule("Player Sky Menu Move Selection Decrease")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.hud_SkyMenu_isOpen == True;
		Throttle Of(Event Player) == Left;
	}

	actions
	{
		Play Effect(Event Player, Explosion Sound, White, Event Player, 15);
		"Difficulty"
		If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[0] && Event Player.player_Difficulty > 0);
			Event Player.player_Difficulty -= 1;
			Call Subroutine(player_SetDifficulty);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[1] && Event Player.player_MysteryMode_Enabled == False);
			If(Event Player.player_KillQuota <= 4);
				Event Player.player_KillQuota = Global.pseudoInfinity;
			Else If(Event Player.player_KillQuota == Global.pseudoInfinity);
				Event Player.player_KillQuota = 64;
			Else;
				Event Player.player_KillQuota -= 4;
			End;
			If(Event Player.currentKillNumber >= Event Player.player_KillQuota);
				Event Player.currentKillNumber = Event Player.player_KillQuota - 1;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[2]);
			If(Event Player.player_CurrentHeroClass > 0);
				Event Player.player_CurrentHeroClass -= 1;
			Else;
				Event Player.player_CurrentHeroClass = 3;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[3] && Event Player.player_MysteryMode_Enabled == True);
			Call Subroutine(player_MysteryMode);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[4] && Event Player.player_MirrorMode_Enabled == True);
			Event Player.player_MirrorMode_Enabled = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[5] && Event Player.player_1SecondCooldown_Enabled == True);
			Call Subroutine(player_1SecondCooldown);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[6] && Event Player.player_DeathPenalty_Enabled == True);
			Event Player.player_DeathPenalty_Enabled = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[7] && Event Player.healing_Enabled == True);
			Event Player.healing_Enabled = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[8] && Players In Slot(Slot Of(Event Player), Team 2)
				.healing_Enabled == True);
			Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[9] && Event Player.player_Unkillable == True);
			Clear Status(Event Player, Unkillable);
			Event Player.player_Unkillable = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[10] && Players In Slot(Slot Of(Event Player), Team 2)
				.bot_UltimateDisabled == True);
			Set Ultimate Ability Enabled(Players In Slot(Slot Of(Event Player), Team 2), True);
			Players In Slot(Slot Of(Event Player), Team 2).bot_UltimateDisabled = False;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[11] && Players In Slot(Slot Of(Event Player), Team 2)
				.bot_Flicker_Enabled == True);
			Players In Slot(Slot Of(Event Player), Team 2).bot_Flicker_Enabled = False;
		End;
		Call Subroutine(skyMenuArrowVisibility);
	}
}

rule("Player Sky Menu Move Selection Increase")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.hud_SkyMenu_isOpen == True;
		Throttle Of(Event Player) == Right;
	}

	actions
	{
		Play Effect(Event Player, Explosion Sound, White, Event Player, 15);
		"Difficulty"
		If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[0] && Event Player.player_Difficulty < 10);
			Event Player.player_Difficulty += 1;
			Call Subroutine(player_SetDifficulty);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[1] && Event Player.player_MysteryMode_Enabled == False);
			If(Event Player.player_KillQuota == 64);
				Event Player.player_KillQuota = Global.pseudoInfinity;
			Else If(Event Player.player_KillQuota == Global.pseudoInfinity);
				Event Player.player_KillQuota = 4;
			Else;
				Event Player.player_KillQuota += 4;
			End;
			If(Event Player.currentKillNumber >= Event Player.player_KillQuota);
				Event Player.currentKillNumber = Event Player.player_KillQuota - 1;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[2]);
			If(Event Player.player_CurrentHeroClass < 3);
				Event Player.player_CurrentHeroClass += 1;
			Else;
				Event Player.player_CurrentHeroClass = 0;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[3] && Event Player.player_MysteryMode_Enabled == False);
			Call Subroutine(player_MysteryMode);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[4] && Event Player.player_MirrorMode_Enabled == False);
			Event Player.player_MirrorMode_Enabled = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[5] && Event Player.player_1SecondCooldown_Enabled == False);
			Call Subroutine(player_1SecondCooldown);
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[6] && Event Player.player_DeathPenalty_Enabled == False);
			Event Player.player_DeathPenalty_Enabled = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[7] && Event Player.healing_Enabled == False);
			Event Player.healing_Enabled = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[8] && Players In Slot(Slot Of(Event Player), Team 2)
				.healing_Enabled == False);
			Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[9] && Event Player.player_Unkillable == False);
			Set Status(Event Player, Null, Unkillable, 9999);
			Event Player.player_Unkillable = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[10] && Players In Slot(Slot Of(Event Player), Team 2)
				.bot_UltimateDisabled == False);
			Set Ultimate Ability Enabled(Players In Slot(Slot Of(Event Player), Team 2), False);
			Players In Slot(Slot Of(Event Player), Team 2).bot_UltimateDisabled = True;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[11] && Players In Slot(Slot Of(Event Player), Team 2)
				.bot_Flicker_Enabled == False);
			Players In Slot(Slot Of(Event Player), Team 2).bot_Flicker_Enabled = True;
		End;
		End;
		Call Subroutine(skyMenuArrowVisibility);
	}
}

rule("Player Sky Menu Arrow Visibility")
{
	event
	{
		Subroutine;
		skyMenuArrowVisibility;
	}

	actions
	{
		If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[0]);
			If(Event Player.player_Difficulty == 0);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_Difficulty == 10);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
			Else;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[1]);
			Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[2]);
			Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[3]);
			If(Event Player.player_MysteryMode_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_MysteryMode_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[4]);
			If(Event Player.player_MirrorMode_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_MirrorMode_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[5]);
			If(Event Player.player_1SecondCooldown_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_1SecondCooldown_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[6]);
			If(Event Player.player_DeathPenalty_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_DeathPenalty_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[7]);
			If(Event Player.healing_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.healing_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[8]);
			If(Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Players In Slot(Slot Of(Event Player), Team 2).healing_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[9]);
			If(Event Player.player_Unkillable == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Event Player.player_Unkillable == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[10]);
			If(Players In Slot(Slot Of(Event Player), Team 2).bot_UltimateDisabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_UltimateDisabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else If(Event Player.hud_SkyMenu_Selection == Event Player.hud_SkyMenu[11]);
			If(Players In Slot(Slot Of(Event Player), Team 2).bot_Flicker_Enabled == False);
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
			Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_Flicker_Enabled == True);
				Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
				Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			End;
		Else;
			Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
			Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
		End;
	}
}

rule("Bot Subroutine: bot_WASD")
{
	event
	{
		Subroutine;
		bot_WASD;
	}

	actions
	{
		Start Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 2)
			.bot_ThrottleDir, 1, To Player, Replace existing throttle, None);
		Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveWASD_TimeMod / 7, Players In Slot(Slot Of(Event Player),
			Team 2).bot_AI_MoveWASD_TimeMod), Ignore Condition);
	}
}

rule("Bot Subroutine: bot_Crouch")
{
	event
	{
		Subroutine;
		bot_Crouch;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_ChanceMod);
			Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
			Start Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
			Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_TimeMod / 5, Players In Slot(Slot Of(
				Event Player), Team 2).bot_AI_MoveCrouch_TimeMod), Ignore Condition);
		End;
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
	}
}

rule("Bot Subroutine: bot_Jump")
{
	event
	{
		Subroutine;
		bot_Jump;
	}

	actions
	{
		If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_ChanceMod);
			Press Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
		End;
		Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_TimeMod / 5, Players In Slot(Slot Of(Event Player),
			Team 2).bot_AI_MoveJump_TimeMod), Ignore Condition);
	}
}

rule("Hard Mode WASD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_Difficulty == 2;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
	}

	actions
	{
		Players In Slot(Slot Of(Event Player), Team 2).bot_ThrottleDir = Random Value In Array(Global.moveDirAll);
		Start Rule(bot_WASD, Do Nothing);
		Start Rule(bot_Crouch, Do Nothing);
		Start Rule(bot_Jump, Do Nothing);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
	}
}

rule("Medium Mode WASD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_Difficulty == 1;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
		(Event Player.currentKillNumber >= Event Player.player_KillQuota / 2 || (
			Event Player.player_KillQuota == Global.pseudoInfinity && Event Player.currentKillNumber % 2 == 1)) == True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
	}

	actions
	{
		Players In Slot(Slot Of(Event Player), Team 2).bot_ThrottleDir = Random Value In Array(Global.moveDirForwards);
		Start Rule(bot_WASD, Do Nothing);
		Start Rule(bot_Crouch, Do Nothing);
		Start Rule(bot_Jump, Do Nothing);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Crouch);
		Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Jump);
	}
}

rule("Easy Mode WASD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_Difficulty == 0;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
		(Event Player.currentKillNumber >= Event Player.player_KillQuota / 2 || (
			Event Player.player_KillQuota == Global.pseudoInfinity && Event Player.currentKillNumber % 2 == 1)) == True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
	}

	actions
	{
		Start Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2), Forward, 1, To Player, Replace existing throttle,
			Direction and Magnitude);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
	}
}

rule("Bot Flicker")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.bot_Flicker_Enabled == True;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Set Invisible(Event Player, All);
		Event Player.bot_AI_CanAim = False;
		Event Player.bot_AI_CanAttack = False;
		Event Player.bot_AI_CanUseAbilities = False;
		Set Status(Event Player, Null, Phased Out, 9999);
		Wait(Random Real(0.350, 3.500), Ignore Condition);
		Set Invisible(Event Player, None);
		Event Player.bot_AI_CanAim = True;
		Event Player.bot_AI_CanAttack = True;
		Event Player.bot_AI_CanUseAbilities = True;
		Clear Status(Event Player, Phased Out);
		Wait(Random Real(0.250, 2.500), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Subroutine: bot_AIMode_Enable")
{
	event
	{
		Subroutine;
		bot_AIMode_Enable;
	}

	actions
	{
		Clear Status(Players In Slot(Slot Of(Event Player), Team 2), Unkillable);
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveWASD_Enabled = True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_Enabled = True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_Enabled = True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_Enabled = True;
	}
}

rule("AI Subroutine: bot_Throttle_Stop")
{
	event
	{
		Subroutine;
		bot_Throttle_Stop;
	}

	actions
	{
		"Wait 4 frames before"
		Wait(4 / 60, Ignore Condition);
		Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
	}
}

rule("AI Subroutine: bot_ReactionDelay")
{
	event
	{
		Subroutine;
		bot_ReactionDelay;
	}

	actions
	{
		Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_ReactionTime / 3, Players In Slot(Slot Of(Event Player),
			Team 2).bot_ReactionTime / 1.500), Ignore Condition);
	}
}

rule("AI Enable")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == False;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty >= 3;
		Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_isOpen == False;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Heal(Event Player, Null, Max Health(Event Player));
		Call Subroutine(bot_AIMode_Enable);
	}
}

rule("AI Disable On Low Difficulty")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
	}

	actions
	{
		Call Subroutine(botReset);
		Wait(2 / 60, Ignore Condition);
		Clear Status(Event Player, Unkillable);
		Wait(2 / 60, Ignore Condition);
		Call Subroutine(botTeleport);
	}
}

rule("AI Attack Melee")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 2.500;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.bot_ViewAngleMod) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Melee);
	}
}

rule("AI Aim Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_HeroInitialized == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_CanAim == True;
	}

	actions
	{
		Wait(6 / 60, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Rule Can Aim")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_HeroInitialized == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Asleep) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Event Player.bot_AI_CanAim = True;
	}
}

rule("AI Rule Can Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Asleep) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Phased Out) == False;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Rule Can Use Abilities")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Hacked) == False;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Asleep) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Phased Out) == False;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Event Player.bot_AI_CanUseAbilities = True;
	}
}

rule("AI Rule Status Hacked")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Hacked) == True;
	}

	actions
	{
		Event Player.bot_AI_CanUseAbilities = False;
	}
}

rule("AI Rule Status Knocked Down")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Event Player.bot_AI_CanAim = False;
		Event Player.bot_AI_CanAttack = False;
		Event Player.bot_AI_CanUseAbilities = False;
		Call Subroutine(bot_Facing_Stop);
	}
}

rule("AI Rule Status Asleep")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Asleep) == True;
	}

	actions
	{
		Event Player.bot_AI_CanAim = False;
		Event Player.bot_AI_CanAttack = False;
		Event Player.bot_AI_CanUseAbilities = False;
		Call Subroutine(bot_Facing_Stop);
	}
}

rule("AI Rule Status Frozen")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		Event Player.bot_AI_CanAim = False;
		Event Player.bot_AI_CanAttack = False;
		Event Player.bot_AI_CanUseAbilities = False;
		Call Subroutine(bot_Facing_Stop);
	}
}

rule("AI Rule Status Phased Out")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Phased Out) == True;
	}

	actions
	{
		Event Player.bot_AI_CanUseAbilities = False;
		Event Player.bot_AI_CanAttack = False;
	}
}

rule("AI Rule Status Stunned")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Stunned) == True;
	}

	actions
	{
		Event Player.bot_AI_CanAim = False;
		Event Player.bot_AI_CanAttack = False;
		Event Player.bot_AI_CanUseAbilities = False;
		Call Subroutine(bot_Facing_Stop);
	}
}

rule("AI Movement WASD Move Closer")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_MoveWASD_Enabled == True;
		Event Player.bot_AI_HeroInitialized == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= Event Player.bot_OptimalDistance;
	}

	actions
	{
		If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1))
			> Event Player.bot_OptimalDistance + Event Player.bot_Throttle_StrafeDistanceMod);
			Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.moveDirForwardsNoStrafe,
				Event Player.bot_ThrottleDir));
		Else;
			Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.moveDirForwards, Event Player.bot_ThrottleDir));
		End;
		Call Subroutine(bot_WASD);
		Loop If Condition Is True;
	}
}

rule("AI Movement WASD Move Farther")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_MoveWASD_Enabled == True;
		Event Player.bot_AI_HeroInitialized == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < Event Player.bot_OptimalDistance;
	}

	actions
	{
		Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.moveDirBackwards, Event Player.bot_ThrottleDir));
		Call Subroutine(bot_WASD);
		Loop If Condition Is True;
	}
}

rule("AI Optimal Distance Default Resize")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(
			Event Player), Team 1).player_EnemyDistanceMax - 2.500;
	}

	actions
	{
		Event Player.bot_OptimalDistance = Random Real(2.500, 5);
		Wait(Random Real(1.500, 3), Ignore Condition);
		Loop If Condition Is True;
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
	}
}

rule("AI Movement Crouch")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_MoveCrouch_Enabled == True;
		Is Alive(Event Player) == True;
		Is In Air(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_Crouch);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Crouch);
	}
}

rule("AI Movement Jump")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_MoveJump_Enabled == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_Jump);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Jump);
	}
}

rule("AI Reaper General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reaper;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(3, 7);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Reaper Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reaper;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Using Ability 1(Event Player) == False;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Reaper Wraith Form")
{
	event
	{
		Player Took Damage;
		Team 2;
		Reaper;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Health(Event Player) < 75;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
		Wait(Random Real(2, 3), Ignore Condition);
		Press Button(Event Player, Primary Fire);
	}
}

rule("AI Reaper Death Blossom")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reaper;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 8;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Tracer General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(4, 6);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Ultimate = 15;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Tracer Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 23;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Tracer Blink")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 7.500) == True;
		Ability Charge(Event Player, Button(Ability 1)) > 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500 + Event Player.bot_ChanceMod);
			Event Player.bot_ThrottleDir = Random Value In Array(Global.moveDirForwards);
			Wait(6 / 60, Ignore Condition);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Tracer Recall")
{
	event
	{
		Player Took Damage;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) < 70;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Tracer Pulse Bomb Update Range")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Event Player.bot_OptimalDistance = Random Real(0.500, 2.500);
	}
}

rule("AI Tracer Pulse Bomb Toss")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 3;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ultimate;
		Event Player.bot_isProjectile = True;
		Call Subroutine(bot_Facing_Body);
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Wait(0.150, Ignore Condition);
		If(Ability Charge(Event Player, Button(Ability 1)) > 0);
			Wait(6 / 60, Ignore Condition);
			Press Button(Event Player, Ability 1);
		End;
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
	}
}

rule("AI Mercy General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(8, 12);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 50;
		Set Weapon(Event Player, 2);
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("Non AI Mercy Wield Staff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == False;
	}

	actions
	{
		Set Weapon(Event Player, 1);
	}
}

rule("AI Mercy Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Mercy Valkyrie Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Mercy Valkyrie Movement")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.bot_OptimalDistance = Random Real(12, 16);
		Event Player.bot_AI_MoveCrouch_Enabled = False;
		Event Player.bot_AI_MoveWASD_Enabled = False;
		Call Subroutine(bot_Throttle_Stop);
		Event Player.bot_Facing_LookAtVector = Vector(X Component Of(Position Of(Event Player)), 100, Z Component Of(Position Of(
			Event Player)));
		Call Subroutine(bot_Facing_LookAt);
		Start Throttle In Direction(Event Player, Vector(0, 0, 1), 1, To Player, Replace existing throttle, Direction and Magnitude);
		Wait(Random Real(0.500, 1.250), Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Start Throttle In Direction(Event Player, Vector(0, 0, -1), 1, To Player, Replace existing throttle, Direction and Magnitude);
		Wait(Random Real(0.500, 1.250), Ignore Condition);
		Event Player.bot_AI_MoveWASD_Enabled = True;
		While(Is Using Ultimate(Event Player) == True);
			Wait(0.500, Ignore Condition);
		End;
		Event Player.bot_AI_MoveCrouch_Enabled = True;
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
	}
}

rule("AI Hanzo General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(15, 20);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Head;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 110;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Hanzo Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Using Ability 2(Event Player) == False;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Primary Fire);
		Wait(Random Real(1.250, 1.750), Ignore Condition);
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500);
			Call Subroutine(bot_Facing_FlickIn);
			Stop Holding Button(Event Player, Primary Fire);
			Call Subroutine(bot_Facing_FlickOut);
		Else;
			Stop Holding Button(Event Player, Primary Fire);
		End;
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Hanzo Sonic Arrow")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Using Ability 2(Event Player) == False;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Hanzo Storm Arrows Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Hanzo Storm Arrows Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Primary Fire);
		Wait(0.350, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Hanzo Dragonstrike")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Using Ability 2(Event Player) == False;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Torbjorn General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(15, 20);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Head;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 70;
		Event Player.bot_ProjectileSpeed_Secondary = 120;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Torbjorn Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.600, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Torbjorn Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 25 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Secondary;
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.800, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Torbjorn Deploy Turret")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ability 1(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-6, 6), 0, Random Real(0,
			3)), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 1);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Torbjorn Overload")
{
	event
	{
		Player Took Damage;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Event Player) <= 90;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Torbjorn Molten Core")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		For Player Variable(Event Player, index, 11, -1, -1);
			Event Player.bot_Facing_LookAtVector = Direction From Angles(Random Integer(1, 360), 0) * Random Real(0, Players In Slot(Slot Of(
				Event Player), Team 1).player_ZoneRadius) + Players In Slot(Slot Of(Event Player), Team 1).player_Home + Vector(0, Random Real(
				0, 3), 0);
			Call Subroutine(bot_Facing_LookAt);
			Wait(Random Real(0.150, 0.250), Ignore Condition);
			Press Button(Event Player, Primary Fire);
		End;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Reinhardt General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(2.250, 4.500);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Ability2 = 25;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Reinhardt Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 6;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Stop Holding Button(Event Player, Secondary Fire);
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Reinhardt Use Shield")
{
	event
	{
		Player Took Damage;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 6;
		Has Status(Players In Slot(Slot Of(Event Player), Team 1), Knocked Down) == False;
	}

	actions
	{
		Wait(0.150, Abort When False);
		If(Random Real(0, 1) < 0.750 + Event Player.bot_ChanceMod);
			Start Holding Button(Event Player, Secondary Fire);
			Wait(Random Real(0.500, 3.500), Ignore Condition);
			Stop Holding Button(Event Player, Secondary Fire);
		End;
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Reinhardt Charge Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) < Players In Slot(Slot Of(Event Player),
			Team 1).player_EnemyDistanceMax - 2.500;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
		Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) < 2;
		Altitude Of(Event Player) < 2;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Hero_Reinhardt_ChargePos = Position Of(Event Player);
		Press Button(Event Player, Ability 1);
	}
}

rule("Special Rule: Reinhardt Charge")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Is Using Ability 1(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(
			Event Player), Team 1).player_ZoneRadius - 3;
		Distance Between(Position Of(Event Player) + World Vector Of(Vector(0, 0, 4), Event Player, Rotation), Players In Slot(Slot Of(
			Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius - 1.250;
	}

	actions
	{
		Call Subroutine(bot_Facing_Stop);
		Set Status(Event Player, Null, Stunned, 0.650);
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		If(Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) && Distance Between(
			Event Player, Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player)))) < 2);
			Start Forcing Player Position(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Position Of(
				Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player)))), False);
			Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player, 300);
		End;
		Wait(0.650, Ignore Condition);
		Stop Forcing Player Position(Event Player);
		Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))));
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Reinhardt Firestrike")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ability2;
		Event Player.bot_isProjectile = True;
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(0.250, Ignore Condition);
		Event Player.bot_Facing_Other_Mod = 0.750;
		Call Subroutine(bot_Facing_Other);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.600, Ignore Condition);
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Reinhardt Earthshatter")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 25 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 17.500;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Health(Event Player) >= 100;
		Is On Ground(Event Player) == True;
		Is On Ground(Players In Slot(Slot Of(Event Player), Team 1)) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Disallow Button(Event Player, Secondary Fire);
		Press Button(Event Player, Ultimate);
		Wait(0.950, Ignore Condition);
		If(Has Status(Players In Slot(Slot Of(Event Player), Team 1), Knocked Down));
			Event Player.bot_Throttle_StrafeDistanceMod = 0;
			Event Player.bot_AI_MoveCrouch_Enabled = False;
			If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
				Press Button(Event Player, Ability 1);
			End;
			Wait(2.500, Ignore Condition);
			Event Player.bot_Throttle_StrafeDistanceMod = 5;
			Event Player.bot_AI_MoveCrouch_Enabled = True;
		End;
		Allow Button(Event Player, Secondary Fire);
	}
}

rule("AI Pharah General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(9, 12);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_Throttle_StrafeDistanceMod = 10;
		Event Player.bot_FacingDefault = Global.facingDefault_Position;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 35;
		Event Player.bot_ProjectileSpeed_Ability2 = 60;
		Event Player.bot_ProjectileSpeed_Ultimate = 45;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Pharah Hover Jets")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Pharah Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Primary Fire);
		Wait(0.850, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Pharah Jump Jet")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Pharah Concussive Blast")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ability2;
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Pharah Barrage")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Altitude Of(Event Player) >= 3;
		Altitude Of(Event Player) <= 12;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ultimate;
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Winston General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(3, 6);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_Throttle_StrafeDistanceMod = 1.500;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Winston Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.750, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Winston Jump Pack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > Event Player.bot_OptimalDistance + 5;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveWASD_Enabled = False;
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, Players In Slot(Slot Of(Event Player), Team 1)), 1,
			To World, Replace existing throttle, Direction and Magnitude);
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Vector(0, Distance Between(
			Event Player, Players In Slot(Slot Of(Event Player), Team 1)) * 0.150, 0);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_AI_MoveWASD_Enabled = True;
	}
}

rule("AI Winston Barrier Projector")
{
	event
	{
		Player Took Damage;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Event Player) <= 350;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance + 10;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.700 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 2);
		End;
	}
}

rule("AI Winston Primal Rage")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 125;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Event Player.bot_OptimalDistance = Random Real(1.500, 3);
		Wait(10, Abort When False);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
	}
}

rule("AI Widowmaker General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Integer(20, 40);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_Throttle_StrafeDistanceMod = 10;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("Non AI Widowmaker Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber % 2 == 0);
			Stop Holding Button(Event Player, Secondary Fire);
			Wait(3 / 60, Ignore Condition);
			Start Holding Button(Event Player, Secondary Fire);
			Event Player.bot_AI_MoveJump_Enabled = False;
		Else;
			Skip If(Is Button Held(Event Player, Secondary Fire) == False, 1);
			Stop Holding Button(Event Player, Secondary Fire);
			Event Player.bot_AI_MoveJump_Enabled = True;
		End;
	}
}

rule("AI Widowmaker Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
		Is Using Ability 1(Event Player) == False;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveJump_Enabled = False;
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(3 / 60, Ignore Condition);
		Start Holding Button(Event Player, Secondary Fire);
		Call Subroutine(bot_Facing_Head);
	}
}

rule("AI Widowmaker Scope Out")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500 || Is Alive(Players In Slot(Slot Of(
			Event Player), Team 1)) == False) == True;
		Is Using Ability 1(Event Player) == False;
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveJump_Enabled = True;
		Stop Holding Button(Event Player, Secondary Fire);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Widowmaker Charge And Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Firing Secondary(Event Player) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 5 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Wait(Random Real(1.300, 1.600), Ignore Condition);
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500);
			Call Subroutine(bot_Facing_FlickIn);
			Press Button(Event Player, Primary Fire);
			Call Subroutine(bot_Facing_FlickOut);
		Else;
			Press Button(Event Player, Primary Fire);
		End;
		Loop If Condition Is True;
	}
}

rule("AI Widowmaker Attack SMG")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Widowmaker Grappling Hook Closer")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ability 1(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > Event Player.bot_OptimalDistance + 5;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = False;
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-8, 8), 0, Random Real(8,
			16)), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(Random Real(0.250, 0.350), Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(Random Real(0.250, 0.350), Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Widowmaker Grappling Hook Farther")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ability 1(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < Event Player.bot_OptimalDistance - 5;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = False;
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-8, 8), 0, Random Real(-8,
			-16)), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(Random Real(0.250, 0.350), Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(Random Real(0.250, 0.350), Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Widowmaker Venom Mine")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Vector(0, Distance Between(
			Event Player, Players In Slot(Slot Of(Event Player), Team 1)) * 0.130, 0);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.150, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Widowmaker Infra-Sight")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Event Player) >= 75;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Bastion General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(18, 22);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Ultimate = 60;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Bastion Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Bastion Reconfigure")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Moving(Event Player) == True;
	}

	actions
	{
		If(Random Real(0, 1) < 0.350 + Event Player.bot_ChanceMod);
			Call Subroutine(bot_ReactionDelay);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Bastion Self-Repair")
{
	event
	{
		Player Took Damage;
		Team 2;
		Bastion;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) <= Max Health(Event Player) / 2;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait((Max Health(Event Player) - Health(Event Player)) / 75, Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Bastion Configuration: Tank")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Event Player) >= 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ultimate;
		Event Player.bot_isProjectile = True;
		Press Button(Event Player, Ultimate);
		Call Subroutine(bot_Facing_Position);
		Wait(8, Ignore Condition);
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Symmetra General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(6, 10);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Secondary = 25;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Symmetra Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 3);
		Stop Holding Button(Event Player, Secondary Fire);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Symmetra Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 12;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Secondary;
		Event Player.bot_isProjectile = True;
		Call Subroutine(bot_Facing_Reset);
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Stop Holding Button(Event Player, Primary Fire);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.500, 1), Ignore Condition);
		Stop Holding Button(Event Player, Primary Fire);
		Loop If Condition Is True;
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Symmetra Sentry Turret")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Event Player.bot_AI_CanAim == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Charge(Event Player, Button(Ability 1)) > 0;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = False;
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + World Vector Of(Vector(
			Random Real(-8, 8), 0, Random Real(-8, 8)), Players In Slot(Slot Of(Event Player), Team 1), Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(Random Real(0.350, 0.450), Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(0.200, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Symmetra Photon Barrier")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Wait(0.200, Ignore Condition);
		Press Button(Event Player, Ultimate);
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Primary Fire);
	}
}

rule("AI Zenyatta General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(12, 16);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 90;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Zenyatta Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Button Held(Event Player, Secondary Fire) == False;
		Is Using Ultimate(Event Player) == False;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 1);
		Start Holding Button(Event Player, Primary Fire);
		Call Subroutine(bot_ReactionDelay);
		Wait(0.400, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Zenyatta Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ultimate(Event Player) == False;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Primary Fire);
		Skip If(Is Button Held(Event Player, Secondary Fire), 1);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(2.500, Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Zenyatta Orb of Discord")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 5 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 75;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Zenyatta Transcendence")
{
	event
	{
		Player Took Damage;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Event Player) < 50;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Genji General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(5, 10);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 60;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Genji Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.950, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Genji Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500);
			Call Subroutine(bot_Facing_FlickIn);
			Press Button(Event Player, Secondary Fire);
			Call Subroutine(bot_Facing_FlickOut);
		Else;
			Press Button(Event Player, Secondary Fire);
		End;
		Wait(0.750, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Genji Deflect")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 7.500 + Event Player.bot_ViewAngleMod) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Array Contains(Global.projectileHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True;
		Is Button Held(Players In Slot(Slot Of(Event Player), Team 1), Primary Fire) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.550 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 2);
		End;
	}
}

rule("AI Genji Deflect Deadeye")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Hero Of(Players In Slot(Slot Of(Event Player), Team 1)) == Hero(McCree);
		Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Genji Swift Strike Movement")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 2(Event Player) == False;
		Ultimate Charge Percent(Event Player) < 85;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500 - Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Genji Swift Strike Final")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12.500;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ability 2(Event Player) == False;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Genji Dragonblade")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 2(Event Player) == False;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 50;
		Health(Event Player) >= 75;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15 && Ability Cooldown(Event Player, Button(
			Ability 1)) != 0);
			Press Button(Event Player, Ultimate);
		Else;
			Event Player.bot_Facing_LookAtVector = Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))),
				Random Real(10, 15), Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))));
			Call Subroutine(bot_Facing_LookAt);
			Wait(0.250, Ignore Condition);
			Press Button(Event Player, Ability 1);
			Wait(0.150, Ignore Condition);
			Press Button(Event Player, Jump);
			Call Subroutine(bot_Facing_Reset);
			Start Holding Button(Event Player, Ultimate);
		End;
		Event Player.bot_OptimalDistance = Random Real(1, 3);
		Wait(6, Ignore Condition);
		Stop Holding Button(Event Player, Ultimate);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
	}
}

rule("AI Genji Dragonblade Swift Strike Gap Closer")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is Using Ultimate(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 5;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Position);
		Wait(Random Real(0.100, 0.200), Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Genji Dragonblade Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 2(Event Player) == False;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.900, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Genji Double Jump")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Is In Air(Event Player) == True;
	}

	actions
	{
		If(Random Real(0, 1) < 0.850 + Event Player.bot_ChanceMod);
			Wait(Random Real(0.150, 0.250), Ignore Condition);
			Press Button(Event Player, Jump);
		End;
	}
}

rule("AI Roadhog General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(9, 12);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 80;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Roadhog Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.850, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Roadhog Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 38;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.850, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Roadhog Chain Hook")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Ammo(Event Player, 0) > 1;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 4 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) <= Players In Slot(Slot Of(
			Event Player), Team 1).player_ZoneRadius;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveWASD_Enabled = False;
		Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, None);
		Press Button(Event Player, Ability 1);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.325, Ignore Condition);
		Press Button(Event Player, Melee);
		Wait(0.750, Ignore Condition);
		Stop Holding Button(Event Player, Primary Fire);
		Call Subroutine(bot_Throttle_Stop);
		Event Player.bot_AI_MoveWASD_Enabled = True;
	}
}

rule("AI Roadhog Take A Breather")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) < 100;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Roadhog Whole Hog")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI McCree General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(13, 16);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI McCree Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 45;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI McCree Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 7.500;
		(Has Status(Players In Slot(Slot Of(Event Player), Team 1), Stunned) == True || Health(Players In Slot(Slot Of(Event Player),
			Team 1)) <= 75) == True;
		Is Using Ultimate(Event Player) == False;
		Ammo(Event Player, 0) >= 3;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Position);
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Secondary Fire);
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI McCree Combat Roll")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.750 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI McCree Flashbang")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Skip If(Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)), 1);
		If(Random Real(0, 1) < 0.750 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 2);
		End;
	}
}

rule("AI McCree Deadeye Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 200;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
		(Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 115) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.mccreeDeadeyeUse = True;
	}
}

rule("AI McCree Deadeye Charge")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.mccreeDeadeyeUse == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
	}

	actions
	{
		Event Player.mccreeDeadeyeCharge = 0;
		Event Player.mccreeDeadeyeRate = 100;
		Stop Holding Button(Event Player, Primary Fire);
		Press Button(Event Player, Ultimate);
		Wait(0.200, Ignore Condition);
		Chase Player Variable At Rate(Event Player, mccreeDeadeyeCharge, 2802.500, Event Player.mccreeDeadeyeRate, Destination and Rate);
		Wait(0.800, Abort When False);
		Event Player.mccreeDeadeyeRate = 275;
		Wait(0.500, Abort When False);
		Event Player.mccreeDeadeyeRate = 550;
		Wait(4.600, Abort When False);
		Press Button(Event Player, Primary Fire);
		Event Player.mccreeDeadeyeCharge = 0;
		Event Player.mccreeDeadeyeUse = False;
	}
}

rule("AI McCree Deadeye Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		McCree;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Event Player.mccreeDeadeyeCharge >= Health(Players In Slot(Slot Of(Event Player), Team 1));
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Wait(Random Real(0.100, 0.150), Ignore Condition);
		Stop Chasing Player Variable(Event Player, mccreeDeadeyeCharge);
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Primary Fire);
		Event Player.mccreeDeadeyeUse = False;
	}
}

rule("AI Junkrat General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(9, 12);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 25;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Junkrat Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ultimate(Event Player) == False;
		Ultimate Charge Percent(Event Player) < 98;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.670, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Junkrat Concussion Mine")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Head);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(Random Real(0.450, 0.650), Ignore Condition);
		Press Button(Event Player, Secondary Fire);
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Junkrat Steel Trap")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Head);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Junkrat Riptire Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Junkrat Riptire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Using Ultimate(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10);
			Wait(1, Ignore Condition);
			Press Button(Event Player, Primary Fire);
		Else;
			Wait(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) / 12, Ignore Condition);
			Press Button(Event Player, Primary Fire);
		End;
		Loop If Condition Is True;
	}
}

rule("AI Zarya General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zarya;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(5, 10);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Secondary = 25;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Zarya Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zarya;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Zarya Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zarya;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed_Primary = 25;
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Vector(0, Distance Between(
			Event Player, Players In Slot(Slot Of(Event Player), Team 1)) * 0.110, 0);
		Call Subroutine(bot_Facing_LookAt);
		Press Button(Event Player, Secondary Fire);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Event Player.bot_ProjectileSpeed_Primary = 500;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Zarya Use Bubble")
{
	event
	{
		Player Took Damage;
		Team 2;
		Zarya;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.600 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Zarya Graviton Surge")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zarya;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Position);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ultimate);
		Wait(0.150, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Soldier: 76 General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(15, 20);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Secondary = 50;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Soldier: 76 Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Soldier: 76 Helix Rockets")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Secondary;
		Event Player.bot_isProjectile = True;
		Call Subroutine(bot_Facing_Position);
		Wait(0.150, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
		Wait(0.200, Ignore Condition);
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Soldier: 76 Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > Event Player.bot_OptimalDistance + 2;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Start Holding Button(Event Player, Ability 1);
		Wait(0.600, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Ability 1);
	}
}

rule("AI Soldier: 76 Biotic Field")
{
	event
	{
		Player Took Damage;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) <= 80;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Soldier: 76 Tactical Visor")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Soldier: 76;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Event Player) >= 50;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Lucio General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(5, 7.500);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 50;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Lucio Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.935, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Lucio Crossfade Heal Self")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Health(Event Player) <= 100;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Lucio Crossfade Speed Self")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Health(Event Player) > 100;
		Is In Alternate Form(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Lucio Amp It Up")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		(Health(Event Player) <= 75 || Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Lucio Soundwave Boop")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Event Player) <= 100;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Secondary Fire);
	}
}

rule("AI Lucio Soundwave Final")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Secondary Fire);
	}
}

rule("AI Lucio Sound Barrier")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		LÃºcio;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		(Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)) || Health(Event Player) <= 75) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI D.Va General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(4, 8);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Primary = 50;
		Event Player.bot_ProjectileSpeed_Ability2 = 40;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI D.Va Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI D.Va Boosters")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 90 + Event Player.bot_ViewAngleMod) == True;
		Ultimate Charge Percent(Event Player) <= 95;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI D.Va Boosters Cancel")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI D.Va Micro Missiles")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ability2;
		Event Player.bot_isProjectile = True;
		Call Subroutine(bot_Facing_Reset);
		Press Button(Event Player, Ability 2);
		Wait(1, Ignore Condition);
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI D.Va Defense Matrix")
{
	event
	{
		Player Took Damage;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Array Contains(Global.projectileHeroes, Hero Of(Attacker)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.800 + Event Player.bot_ChanceMod);
			Start Holding Button(Event Player, Secondary Fire);
			Wait(Random Real(0.200, 0.700), Ignore Condition);
			Stop Holding Button(Event Player, Secondary Fire);
		End;
	}
}

rule("AI D.Va Self-Destruct")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In Alternate Form(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
			Press Button(Event Player, Ability 1);
			Event Player.bot_Facing_LookAtVector = Players In Slot(Slot Of(Event Player), Team 1).player_Home + Vector(0, 15, 0);
			Call Subroutine(bot_Facing_LookAt);
			Wait(Random Real(0.250, 0.500), Ignore Condition);
			Press Button(Event Player, Ultimate);
			Wait(Random Real(0.125, 0.250), Ignore Condition);
			Call Subroutine(bot_Facing_Reset);
		Else;
			Press Button(Event Player, Ultimate);
		End;
	}
}

rule("AI D.Va Call Mech")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Wait(3.500, Ignore Condition);
		Press Button(Event Player, Ultimate);
	}
}

rule("Non AI D.Va Call Mech")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
		Is Alive(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Mei General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(6, 10);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 20;
		Event Player.bot_ProjectileSpeed_Secondary = 115;
		Event Player.bot_ProjectileSpeed_Ultimate = 20;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Mei Attack Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == False;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) > 75;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.200, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Mei Attack Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
		(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10 || Health(Players In Slot(Slot Of(
			Event Player), Team 1)) <= 75) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == False;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Secondary;
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.800, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Mei Attack Secondary Frozen")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == True;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed_Primary = 115;
		Event Player.bot_AI_MoveCrouch_Enabled = False;
		Event Player.bot_AI_MoveJump_Enabled = False;
		Stop Holding Button(Event Player, Primary Fire);
		Event Player.bot_Facing_LookAtVector = Eye Position(Players In Slot(Slot Of(Event Player), Team 1));
		Call Subroutine(bot_Facing_LookAt);
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.800, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
		Call Subroutine(bot_Facing_Reset);
		Event Player.bot_AI_MoveCrouch_Enabled = True;
		Event Player.bot_AI_MoveJump_Enabled = True;
	}
}

rule("AI Mei Cryo-Freeze")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Event Player) <= 70;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
		While(Health(Event Player) < 150);
			Wait(0.250, Ignore Condition);
		End;
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Mei Ice Wall")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is On Ground(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + World Vector Of(Vector(0, 0,
			2.500), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(Random Real(0.200, 0.400), Ignore Condition);
		Press Button(Event Player, Primary Fire);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Mei Blizzrd")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mei;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ultimate;
		Call Subroutine(bot_Facing_Position);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ultimate);
		Wait(0.500, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Sombra General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(5, 8);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
			Press Button(Event Player, Ability 1);
		End;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Sombra Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Sombra Hack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.bot_ViewAngleMod) == False;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Is Using Ability 1(Event Player) == True);
			Press Button(Event Player, Ability 1);
			Wait(0.800, Ignore Condition);
		End;
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.750, Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Sombra Translocator Place")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Using Ability 2(Event Player) == False;
		Is Firing Secondary(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-5, 5), Random Real(1, 3),
			Random Real(-10, -15)), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.150, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Sombra Translocator Use")
{
	event
	{
		Player Took Damage;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) <= 75;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
		Wait(1 / 60, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.250, Ignore Condition);
		Heal(Event Player, Null, 75);
	}
}

rule("AI Sombra EMP")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Sombra Stealth")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Doomfist General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(3, 6);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_Throttle_StrafeDistanceMod = 3;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 80;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Doomfist Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
		Is Button Held(Event Player, Secondary Fire) == False;
		Ammo(Event Player, 0) > 0;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.333, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Doomfist Uppercut")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Primary Fire);
		Wait(1 / 60, Ignore Condition);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Doomfist Seismic Slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 2 || Is In Air(Event Player)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 14;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is Button Held(Event Player, Secondary Fire) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Jump);
		Call Subroutine(bot_Facing_Position);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Doomfist Rocket Punch")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.900, 1.800), Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Doomfist Rocket Punch Gap Closer")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= Event Player.bot_OptimalDistance * 3.500;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.750, 1.500), Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.100, 0.250), Ignore Condition);
		Press Button(Event Player, Primary Fire);
	}
}

rule("AI Doomfist Meteor Strike")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Doomfist;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.bot_ViewAngleMod) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) > 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 1.500;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Call Subroutine(bot_Facing_Position);
		Event Player.bot_OptimalDistance = 0;
		While(Is Using Ultimate(Event Player));
			Wait(10 / 60, Ignore Condition);
			If(Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))), Vector(
				X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), 0, Z Component Of(Position Of(Players In Slot(
				Slot Of(Event Player), Team 1))))) <= 2);
				Press Button(Event Player, Primary Fire);
			End;
		End;
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(15, 20);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 125;
		Event Player.bot_ProjectileSpeed_Ability1 = 60;
		Event Player.bot_ProjectileSpeed_Ability2 = 30;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("Non AI Ana Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber % 2 == 0);
			Stop Holding Button(Event Player, Secondary Fire);
			Wait(3 / 60, Ignore Condition);
			Start Holding Button(Event Player, Secondary Fire);
			Event Player.bot_AI_MoveJump_Enabled = False;
		Else;
			Skip If(Is Button Held(Event Player, Secondary Fire) == False, 1);
			Stop Holding Button(Event Player, Secondary Fire);
			Event Player.bot_AI_MoveJump_Enabled = True;
		End;
	}
}

rule("AI Ana Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Event Player.bot_isProjectile = False;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana Scope Out")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Event Player.bot_isProjectile = True;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.800, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Ana Sleep Dart")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 5 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ability1;
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Ana Sleep Dart Face Enemy Asleep")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Has Status(Players In Slot(Slot Of(Event Player), Team 1), Asleep) == True;
	}

	actions
	{
		While(Ability Cooldown(Event Player, Button(Ability 2)) <= 4 && Ability Cooldown(Event Player, Button(Ability 2)) > 0);
			Skip If(Event Player.bot_AI_CanAttack == False, 1);
			Event Player.bot_AI_CanAttack = False;
			Wait(0.250, Ignore Condition);
		End;
		Event Player.bot_AI_CanAttack = True;
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_Other_Mod = 0.250;
		Call Subroutine(bot_Facing_Other);
		Wait(0.800, Ignore Condition);
		Loop If Condition Is True;
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana Biotic Grenade")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Is Using Ability 2(Event Player) == False;
		Health(Event Player) > 100;
		Is On Ground(Event Player) == True;
		Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Start Facing(Event Player, Direction From Angles(Horizontal Angle Towards(Event Player, Position Of(Players In Slot(Slot Of(
			Event Player), Team 1))), 0.500 * Arcsine In Degrees(-9.800 * (Distance Between(Position Of(Event Player), Position Of(
			Players In Slot(Slot Of(Event Player), Team 1))) - 4) / 30 ^ 2)), Random Integer(Event Player.bot_FacingCapMin,
			Event Player.bot_FacingCapMax), To Player, Direction and Turn Rate);
		Wait(Random Real(0.300, 0.400), Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana Biotic Grenade Self")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) <= 100;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player);
		Call Subroutine(bot_Facing_LookAt);
		Wait(Random Real(0.150, 0.200), Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.150, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ana Nano Boost")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ana;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Orisa General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(12, 16);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed = 120;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Orisa Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Orisa Protective Barrier")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(0, 0, 2), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.200, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.200, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Orisa Halt!")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + World Vector Of(Vector(
			Random Real(-3, 3), Random Real(3, 6), 0), Players In Slot(Slot Of(Event Player), Team 1), Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.200, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
		Wait(0.150, Ignore Condition);
		Skip If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 9, 1);
		Wait(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) * 0.045, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
	}
}

rule("AI Orisa Fortify")
{
	event
	{
		Player Took Damage;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.333 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Orisa Supercharger")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.bot_OptimalDistance;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Brigitte General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(4, 6);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Brigitte Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 90 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.600, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Brigitte Use Shield")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.500 + Event Player.bot_ChanceMod);
			Skip If(Is Button Held(Event Player, Secondary Fire), 1);
			Start Holding Button(Event Player, Secondary Fire);
			Wait(Random Real(0.500, 2.500), Ignore Condition);
			Stop Holding Button(Event Player, Secondary Fire);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Brigitte Shield Bash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 40 + Event Player.bot_ViewAngleMod) == True;
		Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
		Altitude Of(Event Player) <= 2;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 6.850;
		Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.750 + Event Player.bot_ChanceMod);
			Wait(0.200, Ignore Condition);
			Stop Holding Button(Event Player, Primary Fire);
			Start Holding Button(Event Player, Secondary Fire);
			Wait(0.150, Ignore Condition);
			Press Button(Event Player, Primary Fire);
			Wait(0.100, Ignore Condition);
			Stop Holding Button(Event Player, Secondary Fire);
		End;
	}
}

rule("AI Brigitte Shield Bash Gap Closer")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 12.500;
		Health(Event Player) >= 125;
		Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveJump_Enabled = False;
		Event Player.bot_AI_MoveCrouch_Enabled = False;
		Event Player.bot_AI_MoveWASD_Enabled = False;
		Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, Direction and Magnitude);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Primary Fire);
		Wait(0.150, Ignore Condition);
		Start Holding Button(Event Player, Jump);
		Wait(0.500, Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
		Stop Holding Button(Event Player, Jump);
		Stop Throttle In Direction(Event Player);
		Event Player.bot_AI_MoveWASD_Enabled = True;
		Event Player.bot_AI_MoveJump_Enabled = True;
		Event Player.bot_AI_MoveCrouch_Enabled = True;
	}
}

rule("AI Brigitte Whip Shot Final")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 70;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Brigitte Whip Shot Boop")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) > 100;
		Health(Event Player) < 100;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Brigitte Rally")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Health(Event Player) >= 75;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Moira General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(10, 15);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Moira Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Moira Fade")
{
	event
	{
		Player Took Damage;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Event Player) < 100;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Jump);
		Wait(0.300, Ignore Condition);
		Press Button(Event Player, Ability 1);
		Wait(0.500, Ignore Condition);
		Press Button(Event Player, Jump);
	}
}

rule("AI Moira Biotic Orb Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
		Ultimate Charge Percent(Event Player) < 80;
		Health(Event Player) >= 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) > 75;
		Is Using Ability 1(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.150, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
	}
}

rule("AI Moira Biotic Orb Healing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) < 100;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.150, Ignore Condition);
		Press Button(Event Player, Primary Fire);
		Event Player.bot_AI_MoveWASD_Enabled = False;
		Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, Direction and Magnitude);
		Wait(Random Real(1.200, 1.600), Ignore Condition);
		Event Player.bot_AI_MoveWASD_Enabled = True;
	}
}

rule("AI Moira Coalescence")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Stop Holding Button(Event Player, Secondary Fire);
		Press Button(Event Player, Ability 2);
		Wait(0.200, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Wrecking Ball General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(5, 10);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_AI_MoveJump_Enabled = False;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Wrecking Ball Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Wrecking Ball Roll")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 15;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Wrecking Ball Adaptive Shield")
{
	event
	{
		Player Took Damage;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Health(Event Player) <= 150;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Wrecking Ball Piledriver")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
		Ability Cooldown(Event Player, Button(Crouch)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_AI_MoveCrouch_Enabled = False;
		Press Button(Event Player, Jump);
		Wait(0.200, Ignore Condition);
		Press Button(Event Player, Crouch);
		Event Player.bot_AI_MoveCrouch_Enabled = True;
	}
}

rule("AI Wrecking Ball Minefield")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) > 50;
		Is In Air(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12.500;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Ashe General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(15, 25);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_ProjectileSpeed_Ability2 = 25;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("Non AI Ashe Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty < 3;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber % 2 == 0);
			Stop Holding Button(Event Player, Secondary Fire);
			Wait(3 / 60, Ignore Condition);
			Start Holding Button(Event Player, Secondary Fire);
		Else;
			Skip If(Is Button Held(Event Player, Secondary Fire) == False, 1);
			Stop Holding Button(Event Player, Secondary Fire);
		End;
	}
}

rule("AI Ashe Attack Scope In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAim == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
		Is Reloading(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Ashe Attack Scoped")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAim == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
		Is Reloading(Event Player) == False;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Secondary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(0.700, Ignore Condition);
		If(Random Real(0, 1) < 0.500);
			Call Subroutine(bot_Facing_FlickIn);
			Press Button(Event Player, Primary Fire);
			Call Subroutine(bot_Facing_FlickOut);
		Else;
			Press Button(Event Player, Primary Fire);
		End;
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Secondary Fire);
	}
}

rule("AI Ashe Attack Unscoped")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAim == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
		Is Button Held(Event Player, Secondary Fire) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Primary Fire);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Ashe Reload")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Ammo(Event Player, 0) == 0;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = False;
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Reload);
		Wait(0.500, Ignore Condition);
		For Player Variable(Event Player, index, Ammo(Event Player, 0), Random Integer(8, Max Ammo(Event Player, 0)), 1);
			Wait(0.250, Ignore Condition);
			If(Ammo(Event Player, 0) == Max Ammo(Event Player, 0));
				Break;
			End;
		End;
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Ashe Reload After Kill")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.bot_AI_CanAttack = False;
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Reload);
		Wait(0.500, Ignore Condition);
		For Player Variable(Event Player, index, 0, Random Integer(3, 6), 1);
			Wait(0.250, Ignore Condition);
			If(Ammo(Event Player, 0) == Max Ammo(Event Player, 0));
				Break;
			End;
		End;
		Event Player.bot_AI_CanAttack = True;
	}
}

rule("AI Ashe Coach Gun Defensive")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 9.400;
		Health(Event Player) <= 125;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Ashe Coach Gun Finishing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) < 90;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Ashe Dynamite")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAim == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
		Is Reloading(Event Player) == False;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Hero_Ashe_DynamitePosition = Position Of(Players In Slot(Slot Of(Event Player), Team 1));
		Start Facing(Event Player, Direction From Angles(Horizontal Angle Towards(Event Player, Position Of(Players In Slot(Slot Of(
			Event Player), Team 1))), 0.500 * Arcsine In Degrees(-9.800 * (Distance Between(Position Of(Event Player),
			Event Player.bot_Hero_Ashe_DynamitePosition) - 20) / 25 ^ 2)), Random Integer(Event Player.bot_FacingCapMin,
			Event Player.bot_FacingCapMax), To Player, Direction and Turn Rate);
		Wait(Random Real(0.300, 0.400), Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Ashe B.O.B.")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ashe;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("AI Baptiste General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Baptiste;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(14, 18);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = False;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Baptiste Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Baptiste;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Ammo(Event Player, 0) <= 0);
			Press Button(Event Player, Reload);
			Wait(1.500, Ignore Condition);
		Else;
			Skip If(Is Button Held(Event Player, Primary Fire), 1);
			Start Holding Button(Event Player, Primary Fire);
			Wait(0.650, Ignore Condition);
		End;
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Baptiste Regenerative Burst")
{
	event
	{
		Player Took Damage;
		Team 2;
		Baptiste;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Health(Event Player) <= 75;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Baptiste Immortality Field")
{
	event
	{
		Player Took Damage;
		Team 2;
		Baptiste;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Health(Event Player) <= 75;
		Altitude Of(Event Player) < 3;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Call Subroutine(bot_ReactionDelay);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Baptiste Amplification Matrix")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Baptiste;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Altitude Of(Event Player) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Event Player.bot_Facing_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(0, 0, 2), Event Player, Rotation);
		Call Subroutine(bot_Facing_LookAt);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Primary Fire);
		Wait(0.100, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Sigma General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sigma;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(12, 15);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Position;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 50;
		Event Player.bot_ProjectileSpeed_Ability2 = 37.500;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Sigma Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sigma;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
		Is Using Ability 1(Event Player) == False;
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Sigma Kinetic Grasp")
{
	event
	{
		Player Took Damage;
		Team 2;
		Sigma;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.bot_ViewAngleMod) == True;
		Array Contains(Global.projectileHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		If(Random Real(0, 1) < 0.650 + Event Player.bot_ChanceMod);
			Press Button(Event Player, Ability 1);
		End;
	}
}

rule("AI Sigma Accretion")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sigma;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
		Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 3;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Ability2;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Position Of(Players In Slot(Slot Of(Event Player),
			Team 1)) + Vector(0, Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) * 0.100, 0)),
			Random Integer(Event Player.bot_FacingCapMin, Event Player.bot_FacingCapMax), To World, Direction and Turn Rate);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Ability 2);
		Wait(0.700, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Sigma Experimental Barrier")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sigma;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Skip If(Is Button Held(Event Player, Secondary Fire), 1);
		Start Holding Button(Event Player, Secondary Fire);
		Wait(Random Real(0.150, 0.250), Ignore Condition);
		Stop Holding Button(Event Player, Secondary Fire);
		Wait(4.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AI Sigma Gravitic Flux")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sigma;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 125;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
		Start Holding Button(Event Player, Jump);
		Wait(Random Real(1.750, 3), Ignore Condition);
		Press Button(Event Player, Primary Fire);
		Wait(0.750, Ignore Condition);
		Call Subroutine(bot_Facing_Body);
		Start Holding Button(Event Player, Primary Fire);
		Wait(1.250, Ignore Condition);
		Stop Holding Button(Event Player, Primary Fire);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Echo General")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.bot_AI_Enabled == True;
	}

	actions
	{
		Event Player.bot_OptimalDistanceDefault = Random Real(9, 13);
		Event Player.bot_OptimalDistance = Event Player.bot_OptimalDistanceDefault;
		Event Player.bot_FacingDefault = Global.facingDefault_Body;
		Event Player.bot_isProjectile = True;
		Event Player.bot_ProjectileSpeed_Primary = 75;
		Event Player.bot_ProjectileSpeed_Secondary = 50;
		Event Player.bot_AI_HeroInitialized = True;
	}
}

rule("AI Echo Glide")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is In Air(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Jump);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Jump);
	}
}

rule("AI Echo Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanAttack == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Primary;
		Skip If(Is Button Held(Event Player, Primary Fire), 2);
		Call Subroutine(bot_ReactionDelay);
		Start Holding Button(Event Player, Primary Fire);
		Wait(0.330, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Primary Fire);
	}
}

rule("AI Echo Flight")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 1);
	}
}

rule("AI Echo Focusing Beam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) <= Max Health(Players In Slot(Slot Of(Event Player), Team 1)) / 2;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 16;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ability 2);
	}
}

rule("AI Echo Sticky Bombs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Health(Players In Slot(Slot Of(Event Player), Team 1)) >= Max Health(Players In Slot(Slot Of(Event Player), Team 1)) / 2;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Event Player.bot_ProjectileSpeed = Event Player.bot_ProjectileSpeed_Secondary;
		Event Player.bot_Facing_Other_Mod = 0.250;
		Call Subroutine(bot_Facing_Other);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Secondary Fire);
		Wait(0.750, Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Echo Duplicate")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Echo;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_CanUseAbilities == True;
		Is Alive(Event Player) == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
		Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.bot_ViewAngleMod) == True;
	}

	actions
	{
		Call Subroutine(bot_ReactionDelay);
		Press Button(Event Player, Ultimate);
	}
}

rule("Player Died")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_Difficulty >= 3;
	}

	actions
	{
		Stop Heal Over Time(Event Player.inspireHeal_ID);
		Set Status(Event Player, Null, Invincible, 2.250);
		Stop Forcing Player Position(Event Player);
		Disallow Button(Event Player, Jump);
	}
}

rule("Debug Toggle")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ability 2) == True;
		Is Button Held(Event Player, Reload) == True;
		Is Button Held(Event Player, Jump) == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Call Subroutine(hud_DebugToggle);
	}
}

rule("Subroutine: hud_DebugToggle")
{
	event
	{
		Subroutine;
		hud_DebugToggle;
	}

	actions
	{
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText) > 0);
			Call Subroutine(hud_SkyMenuToggle);
		Else If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
			Call Subroutine(hud_InfoToggle);
		End;
		Wait(3 / 60, Ignore Condition);
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
				.hud_Debug), -1, -1);
				Destroy HUD Text(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
				Players In Slot(Slot Of(Event Player), Team 1).hud_Debug = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
					.hud_Debug, Players In Slot(Slot Of(Event Player), Team 1).hud_Debug[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
			End;
			Players In Slot(Slot Of(Event Player), Team 1).hud_Debug_Enabled = False;
		Else;
			Players In Slot(Slot Of(Event Player), Team 1).hud_Debug = Empty Array;
			Players In Slot(Slot Of(Event Player), Team 1).hud_Debug_Enabled = True;
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Server Load: {0}", Server Load), Custom String(
				"Average: {0}", Server Load Average), Custom String("Peak: {0}", Server Load Peak), Top, 3, Orange, Yellow, Red,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String("Enemy Pos: {0}", Position Of(
				Players In Slot(Slot Of(Event Player), Team 2))), Custom String("Player Pos: {0}", Position Of(Event Player)), Left, 4, Yellow,
				Red, Sky Blue, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Player Dist From Home: {0}", Distance Between(
				Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).player_Home)), Null,
				Custom String("Enemy Dist From Home: {0}", Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(
				Slot Of(Event Player), Team 1).player_Home)), Left, 5, Yellow, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Enemy Dist From Player: {0}", Distance Between(
				Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 2))), Null, Null, Left, 5.200,
				Yellow, White, Yellow, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Enemy Ult Charge: {0}", Ultimate Charge Percent(
				Players In Slot(Slot Of(Event Player), Team 2))), Null, Null, Right, 6, Turquoise, White, White, Visible To and String,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Player Facing Dir: {0}", Facing Direction Of(
				Event Player)), Null, Custom String("Enemy Facing Dir: {0}", Facing Direction Of(Players In Slot(Slot Of(Event Player),
				Team 2))), Left, 6.100, White, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Primary Fire CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Primary Fire))), Null, Top, 60.100, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Secondary Fire CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Secondary Fire))), Null, Top, 60.200, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Ability 1 CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Ability 1))), Null, Top, 60.300, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Ability 2 CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Ability 2))), Null, Top, 60.400, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Ultimate CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Ultimate))), Null, Top, 60.500, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Crouch CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Crouch))), Null, Top, 60.600, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Jump CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Jump))), Null, Top, 60.700, White, White, White, Visible To and String,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Reload CD: {0}", Ability Cooldown(
				Players In Slot(Slot Of(Event Player), Team 1), Button(Reload))), Null, Top, 60.800, White, White, White,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
		End;
	}
}

rule("Subroutine: hud_InfoToggle")
{
	event
	{
		Subroutine;
		hud_InfoToggle;
	}

	actions
	{
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuText) > 0);
			Call Subroutine(hud_SkyMenuToggle);
		Else If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
			Call Subroutine(hud_DebugToggle);
		End;
		Wait(3 / 60, Ignore Condition);
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
				.hud_Info), -1, -1);
				Destroy HUD Text(Players In Slot(Slot Of(Event Player), Team 1).hud_Info[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
				Players In Slot(Slot Of(Event Player), Team 1).hud_Info = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
					.hud_Info, Players In Slot(Slot Of(Event Player), Team 1).hud_Info[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
			End;
			Players In Slot(Slot Of(Event Player), Team 1).hud_Info_Enabled = False;
		Else;
			Players In Slot(Slot Of(Event Player), Team 1).hud_Info = Empty Array;
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Welcome to Practice Field: Expanse!"),
				Global.twitchURL, Custom String("Created by {0}", Global.programmerName), Top, 3, Sky Blue, Aqua, Purple,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"This workshop mode allows you to thoroughly warm up/practice your movement and aim on and against ALL heroes."),
				Custom String(
				"You are placed in a bubble against one bot opponent. When you kill them enough times it progresses to the next hero in the list."),
				Top, 5, Yellow, White, Green, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String("This is version {0}",
				Global.version), Custom String(
				"The AI modes contain AI for all heroes written from scratch by myself. The bots do not attack below the difficulty \"{0}\".",
				Global.difficultyNames[3]), Top, 5.100, Yellow, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Null, Custom String(
				"There are many difficulties and they correspond to many variables that affect the bots' movement, aim, and reaction time."),
				Top, 5.120, Yellow, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Null, Custom String(
				"Hold {0} and {1} to toggle the menu!", Input Binding String(Button(Reload)), Input Binding String(Button(Melee))), Top, 5.200,
				White, White, Green, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"There are many settings so you can customize your warmup!"), Custom String("See the top left corner for controls."), Top,
				5.300, Yellow, Yellow, Yellow, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Null, Custom String(
				"For the most recent version: Please import code: {0}", Global.workshopCode), Top, 7, Yellow, White, Aqua,
				Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"Press {0} and {1} to hide this text", Input Binding String(Button(Crouch)), Input Binding String(Button(Interact))), Null,
				Top, 8, Yellow, White, Sky Blue, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Info, Append To Array, Last Text ID);
			Players In Slot(Slot Of(Event Player), Team 1).hud_Info_Enabled = True;
			"Auto-close after 20 seconds open"
			Wait(20, Ignore Condition);
			If(Event Player.hud_Info_Enabled == True);
				Call Subroutine(hud_InfoToggle);
			End;
		End;
	}
}

rule("Subroutine: hud_MainFixedToggle")
{
	event
	{
		Subroutine;
		hud_MainFixedToggle;
	}

	actions
	{
		If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed) > 0);
			For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
				.hud_MainFixed), -1, -1);
				Destroy HUD Text(Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed[Players In Slot(Slot Of(Event Player), Team 1)
					.hud_i]);
				Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
					.hud_MainFixed, Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed[Players In Slot(Slot Of(Event Player), Team 1)
					.hud_i]);
			End;
		Else;
			Wait(12 / 60, Ignore Condition);
			Players In Slot(Slot Of(Event Player), Team 1).hud_MainFixed = Empty Array;
			"Padding"
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String(" "), Custom String(" "), Left, -3.100, White,
				White, White, None, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String(" "), Custom String(" "), Left, -3.200, White,
				White, White, None, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			"Create Left Side HUD Text"
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("{0}", Global.workshopCode), Custom String(
				"Version {0}, Created by {1}", Global.version, Global.programmerName), Custom String("Practice Field: Expanse",
				Global.version), Left, -3, Aqua, Sky Blue, Turquoise, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"Press {0} and {1} to show/hide info", Input Binding String(Button(Crouch)), Input Binding String(Button(Interact))), Null,
				Left, -1.890, White, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"Hold {0} and {1} to change heroes", Input Binding String(Button(Crouch)), Input Binding String(Button(Reload))), Null, Left,
				-1.800, White, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"Hold {0} and {1} to select specific enemy hero", Input Binding String(Button(Interact)), Input Binding String(Button(
				Reload))), Custom String("Hold {0} and {1} to open/close the menu", Input Binding String(Button(Reload)), Input Binding String(
				Button(Melee))), Left, -1.600, White, White, Yellow, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String(
				"Hold {0} and press {1} or {2} to cycle enemy hero", Input Binding String(Button(Interact)), Input Binding String(Button(
				Primary Fire)), Input Binding String(Button(Secondary Fire))), Null, Left, -1.600, White, White, Yellow, Visible To and String,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			"Create Right Side HUD Text"
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("{0} Kills: {1} / {2}", Hero Icon String(
				Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroList[Players In Slot(Slot Of(Event Player), Team 1)
				.player_CurrentHero]), Players In Slot(Slot Of(Event Player), Team 1).currentKillNumber, Players In Slot(Slot Of(Event Player),
				Team 1).player_KillQuota == Global.pseudoInfinity ? Custom String("Infinite") : Players In Slot(Slot Of(Event Player), Team 1)
				.player_KillQuota), Null, Null, Right, -3, White, White, White, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("{0} killed you {1} time(s).", Hero Of(
				Players In Slot(Slot Of(Event Player), Team 2)), Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber), Null,
				Right, -2.900, White, White, Red, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Hero Type: {0}", Players In Slot(Slot Of(
				Event Player), Team 1).player_CurrentHeroListName), Custom String("Hero {0} of {1}", 1 + Players In Slot(Slot Of(Event Player),
				Team 1).player_CurrentHero, Count Of(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroList)), Right, -2.200,
				White, White, Yellow, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String(""), Custom String("Next Hero: {0}", Players In Slot(
				Slot Of(Event Player), Team 1).player_MysteryMode_Enabled == True ? Custom String("?") : Hero Icon String(Players In Slot(
				Slot Of(Event Player), Team 1).player_CurrentHeroList[Players In Slot(Slot Of(Event Player), Team 1).nextHero])), Null, Right,
				-2, White, Aqua, Aqua, Visible To and String, Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
			Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Difficulty: {0}", Players In Slot(Slot Of(
				Event Player), Team 1).player_DifficultyName), Null, Right, -0.900, White, Orange, White, Visible To and String,
				Default Visibility);
			Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_MainFixed, Append To Array, Last Text ID);
		End;
	}
}

rule("Help Skip Message")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber >= 2;
		Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber > Event Player.currentKillNumber;
		Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber % 2 == 0;
		Event Player.player_Difficulty >= 3;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 2).currentKillNumber % 4 == 0);
			Small Message(Event Player, Custom String("Tip: Difficulty can be lowered in the menu"));
		End;
		Small Message(Event Player, Custom String("To skip {0} hold {1} and press {2}", Hero Icon String(Hero Of(Players In Slot(Slot Of(
			Event Player), Team 2))), Input Binding String(Button(Interact)), Input Binding String(Button(Primary Fire))));
	}
}

rule("Special Rule: Doomfist Rocket Punch Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) == True;
		Distance Between(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Players In Slot(Slot Of(
			Event Player), Team 1).player_Home) >= Players In Slot(Slot Of(Event Player), Team 1).player_ZoneRadius - 1;
	}

	actions
	{
		Apply Impulse(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Direction Towards(Players In Slot(
			Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player), 1, To World, Cancel Contrary Motion);
		Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player,
			Event Player.doomfistPunchDamage);
		Event Player.doomfistPunchCharge = 0;
		Event Player.doomfistPunchDamage = 0;
	}
}

rule("Player Ana Self Nano Boost")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Ana;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Is Button Held(Event Player, Ultimate) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
		Wait(0.150, Ignore Condition);
		Abort If(Is Alive(Event Player) == False);
		Set Ultimate Ability Enabled(Event Player, False);
		Big Message(Event Player, Custom String("NANO BOOST ACTIVATED!"));
		Play Effect(All Players(All Teams), Good Pickup Effect, Blue, Event Player, 2);
		Play Effect(All Players(All Teams), Explosion Sound, White, Event Player, 50);
		Heal(Event Player, Event Player, 250);
		Start Damage Modification(Players In Slot(Slot Of(Event Player), Team 2), Event Player, 150,
			Receivers Damagers and Damage Percent);
		Event Player.player_DamageModDealt_ID = Last Damage Modification ID;
		Start Damage Modification(Event Player, Players In Slot(Slot Of(Event Player), Team 2), 50, Receivers Damagers and Damage Percent);
		Event Player.player_DamageModReceived_ID = Last Damage Modification ID;
		For Player Variable(Event Player, index, 0, 9, 0.250);
			If(Is Alive(Event Player));
				Wait(0.250, Ignore Condition);
			Else;
				Break;
			End;
		End;
		Set Ultimate Ability Enabled(Event Player, True);
		Stop Damage Modification(Event Player.player_DamageModDealt_ID);
		Stop Damage Modification(Event Player.player_DamageModReceived_ID);
	}
}

rule("Subroutine: bot_Facing_FlickIn")
{
	event
	{
		Subroutine;
		bot_Facing_FlickIn;
	}

	actions
	{
		Wait(2 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_FlickPoint = Facing Direction Of(Event Player);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Event Player), Eye Position(
			Players In Slot(Slot Of(Event Player), Team 1))), Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
			.bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax), To World, Direction and Turn Rate);
		Wait(Random Real(0.100, 0.200), Ignore Condition);
	}
}

rule("Subroutine: bot_Facing_FlickOut")
{
	event
	{
		Subroutine;
		bot_Facing_FlickOut;
	}

	actions
	{
		Wait(0.033, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_FlickPoint,
			Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2)
			.bot_FacingCapMax), To World, None);
		Wait(Random Real(0.100, 0.200), Ignore Condition);
		Call Subroutine(bot_Facing_Reset);
	}
}

rule("AI Movement WASD Strafe On Dmg")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.bot_AI_Enabled == True;
		Event Player.bot_AI_MoveWASD_Enabled == True;
		Event Player.bot_AI_HeroInitialized == True;
		Is Alive(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1))
			> Event Player.bot_OptimalDistance + Event Player.bot_Throttle_StrafeDistanceMod;
		Event Damage > 25;
	}

	actions
	{
		If(Random Real(0, 1) < 0.700 + Event Player.bot_ChanceMod);
			Event Player.bot_ThrottleDir = Random Value In Array(Global.moveDirStrafe);
			Call Subroutine(bot_WASD);
		End;
	}
}

rule("Reset Bot Position Out Of Bounds")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Has Spawned(Event Player) == True;
		Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).player_Home) > Players In Slot(Slot Of(Event Player),
			Team 1).player_EnemyDistanceMax + 15;
	}

	actions
	{
		Wait(0.750, Abort When False);
		Call Subroutine(botTeleport);
	}
}

rule("Subroutine: player_SetDifficulty")
{
	event
	{
		Subroutine;
		player_SetDifficulty;
	}

	actions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_DifficultyName = Global.difficultyNames[Players In Slot(Slot Of(
			Event Player), Team 1).player_Difficulty];
		Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base = 1 + 0.010 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin = 2.500 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMax = 5 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin = 90 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax = 135 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier = 0.500 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveWASD_TimeMod = 1 - 0.100 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty * 0.550 + 0.150;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_TimeMod = 0.080 * Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_ChanceMod = 0.100 + Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty * 0.010;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_TimeMod = 1 + Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty * 0.070;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveJump_ChanceMod = 0.160 + Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty * 0.030;
		Players In Slot(Slot Of(Event Player), Team 2).bot_ReactionTime = Absolute Value(0.080 * Players In Slot(Slot Of(Event Player),
			Team 1).player_Difficulty - 0.870);
		Players In Slot(Slot Of(Event Player), Team 2).bot_ChanceMod = Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty / 100;
		Players In Slot(Slot Of(Event Player), Team 2).bot_ViewAngleMod = Absolute Value(Players In Slot(Slot Of(Event Player), Team 1)
			.player_Difficulty - Global.difficultyMax);
		Players In Slot(Slot Of(Event Player), Team 1).player_SelfHealAmount = Absolute Value(Players In Slot(Slot Of(Event Player),
			Team 1).player_Difficulty - 9.500) * 0.100;
	}
}

rule("Subroutine: setHeroClass")
{
	event
	{
		Subroutine;
		setHeroClass;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroListName != Global.heroClassNames[Players In Slot(Slot Of(
			Event Player), Team 1).player_CurrentHeroClass]);
			Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroList = Randomized Array(Global.heroClasses[Players In Slot(
				Slot Of(Event Player), Team 1).player_CurrentHeroClass]);
			Players In Slot(Slot Of(Event Player), Team 1).player_CurrentHeroListName = Global.heroClassNames[Players In Slot(Slot Of(
				Event Player), Team 1).player_CurrentHeroClass];
		End;
	}
}

rule("AI Subroutine: bot_Facing_Head_Projectile")
{
	event
	{
		Subroutine;
		bot_Facing_Head_Projectile;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		If(Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty >= 3);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Angle Towards(Players In Slot(
				Slot Of(Event Player), Team 2), Position Of(Players In Slot(Slot Of(Event Player), Team 1))), 0.500 * Arcsine In Degrees(
				-9.800 * Distance Between(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Eye Position(Players In Slot(Slot Of(
				Event Player), Team 1))) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed ^ 2)), Min(Random Integer(360,
				540), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(
				Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Eye Position(Players In Slot(Slot Of(Event Player), Team 1))))), To Player, Direction and Turn Rate);
		Else If(Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty == 9);
		End;
	}
}

rule("AI Subroutine: bot_Facing_Body")
{
	event
	{
		Subroutine;
		bot_Facing_Body;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		"Aim at the body of the player"
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_isProjectile == True);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(
				Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(
				Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2)
				.bot_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)), Min(
				Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingCapMax), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(
				Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(
				Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(
				Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2)
				.bot_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)))
				+ Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(
				Players In Slot(Slot Of(Event Player), Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1))
				* Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (
				Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1))
				/ Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(Event Player),
				Team 1)) - Vector(0, 0.250, 0))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		Else;
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)), Min(Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingCapMax), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(
				Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0))) + Angle Between Vectors(
				Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(
				Event Player), Team 2)), Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0))) * Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier) + Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(
				Slot Of(Event Player), Team 2).bot_FacingPadMax)), To World, Direction and Turn Rate);
		End;
	}
}

rule("AI Subroutine: bot_Facing_Head")
{
	event
	{
		Subroutine;
		bot_Facing_Head;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		"Aim at the eye position of the player"
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_isProjectile == True);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(
				Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(
				Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2)
				.bot_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), Min(Random Integer(Players In Slot(
				Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax),
				Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(Players In Slot(
				Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
				World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
				Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player),
				Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed)
				+ Eye Position(Players In Slot(Slot Of(Event Player), Team 1)))) + Angle Between Vectors(Facing Direction Of(Players In Slot(
				Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
				World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
				Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player),
				Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed)
				+ Eye Position(Players In Slot(Slot Of(Event Player), Team 1)))) * Random Integer(Players In Slot(Slot Of(Event Player),
				Team 2).bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier)
				+ Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player),
				Team 2).bot_FacingPadMax)), To World, Direction and Turn Rate);
		Else;
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), Min(Random Integer(Players In Slot(Slot Of(
				Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax), Players In Slot(
				Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(
				Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Eye Position(
				Players In Slot(Slot Of(Event Player), Team 1)))) + Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(
				Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Eye Position(
				Players In Slot(Slot Of(Event Player), Team 1)))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		End;
	}
}

rule("AI Subroutine: bot_Facing_Position")
{
	event
	{
		Subroutine;
		bot_Facing_Position;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		"Aim at the absolute position of the player"
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_isProjectile == True);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(
				Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(
				Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2)
				.bot_ProjectileSpeed) + Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Min(Random Integer(Players In Slot(
				Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax),
				Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(Players In Slot(
				Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
				World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
				Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player),
				Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed)
				+ Position Of(Players In Slot(Slot Of(Event Player), Team 1)))) + Angle Between Vectors(Facing Direction Of(Players In Slot(
				Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
				World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
				Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player),
				Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed)
				+ Position Of(Players In Slot(Slot Of(Event Player), Team 1)))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		Else;
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Min(Random Integer(Players In Slot(Slot Of(
				Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax), Players In Slot(
				Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(
				Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Position Of(
				Players In Slot(Slot Of(Event Player), Team 1)))) + Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(
				Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Position Of(
				Players In Slot(Slot Of(Event Player), Team 1)))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		End;
	}
}

rule("AI Subroutine: bot_Facing_Other")
{
	event
	{
		Subroutine;
		bot_Facing_Other;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		"Aim at a position relative to the player"
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_isProjectile == True);
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(
				Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(
				Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2)
				.bot_ProjectileSpeed) + Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Players In Slot(
				Slot Of(Event Player), Team 2).bot_Facing_Other_Mod, Z Component Of(Position Of(Players In Slot(Slot Of(Event Player),
				Team 1))))), Min(Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(
				Event Player), Team 2).bot_FacingCapMax), Players In Slot(Slot Of(Event Player), Team 2)
				.bot_Facing_Base ^ Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)),
				Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), World Vector Of(Speed Of(Players In Slot(
				Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)), Players In Slot(Slot Of(
				Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(
				Event Player), Team 1)) / Players In Slot(Slot Of(Event Player), Team 2).bot_ProjectileSpeed) + Vector(X Component Of(
				Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Players In Slot(Slot Of(Event Player), Team 2)
				.bot_Facing_Other_Mod, Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1)))))) + Angle Between Vectors(
				Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(
				Event Player), Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(
				Players In Slot(Slot Of(Event Player), Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(
				Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1)) / Players In Slot(Slot Of(
				Event Player), Team 2).bot_ProjectileSpeed) + Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player),
				Team 1))), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Other_Mod, Z Component Of(Position Of(Players In Slot(
				Slot Of(Event Player), Team 1)))))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		Else;
			Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
				Team 2)), Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Players In Slot(Slot Of(
				Event Player), Team 2).bot_Facing_Other_Mod, Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))))),
				Min(Random Integer(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player),
				Team 2).bot_FacingCapMax), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Base ^ Angle Between Vectors(
				Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(Eye Position(Players In Slot(Slot Of(
				Event Player), Team 2)), Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Players In Slot(
				Slot Of(Event Player), Team 2).bot_Facing_Other_Mod, Z Component Of(Position Of(Players In Slot(Slot Of(Event Player),
				Team 1)))))) + Angle Between Vectors(Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 2)), Direction Towards(
				Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Vector(X Component Of(Position Of(Players In Slot(Slot Of(
				Event Player), Team 1))), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_Other_Mod, Z Component Of(Position Of(
				Players In Slot(Slot Of(Event Player), Team 1)))))) * Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingAngleModifier - 0.250, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingAngleModifier) + Random Integer(
				Players In Slot(Slot Of(Event Player), Team 2).bot_FacingPadMin, Players In Slot(Slot Of(Event Player), Team 2)
				.bot_FacingPadMax)), To World, Direction and Turn Rate);
		End;
	}
}

rule("AI Subroutine: bot_Facing_LookAt")
{
	event
	{
		Subroutine;
		bot_Facing_LookAt;
	}

	actions
	{
		Wait(3 / 60, Ignore Condition);
		Abort If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAim == False);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
		"Quickly look at a fixed position in the world"
		Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
			Team 2)), Players In Slot(Slot Of(Event Player), Team 2).bot_Facing_LookAtVector), Random Integer(Players In Slot(Slot Of(
			Event Player), Team 2).bot_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).bot_FacingCapMax), To World,
			Direction and Turn Rate);
	}
}

rule("AI Subroutine: bot_Facing_Reset")
{
	event
	{
		Subroutine;
		bot_Facing_Reset;
	}

	actions
	{
		If(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingDefault == Global.facingDefault_Body);
			Call Subroutine(bot_Facing_Body);
		Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingDefault == Global.facingDefault_Head);
			Call Subroutine(bot_Facing_Head);
		Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingDefault == Global.facingDefault_Position);
			Call Subroutine(bot_Facing_Position);
		Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_FacingDefault == Global.facingDefault_Other);
			Call Subroutine(bot_Facing_Other);
		End;
	}
}

rule("Special Rule: Player Sombra Disable Enemy Attack")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_Enabled == True;
		Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Skip If(Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAttack == False, 2);
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_Enabled = False;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAttack = False;
		Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Random Integer(1, 360), Random Integer(-5, 5)),
			Random Integer(180, 360), To Player, Direction and Turn Rate);
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		If(Random Real(0, 1) < 0.050);
			Communicate(Players In Slot(Slot Of(Event Player), Team 2), Hello);
		End;
		Loop If Condition Is True;
		Wait(0.250, Ignore Condition);
		Call Subroutine(bot_Facing_Stop);
		Call Subroutine(bot_Facing_Reset);
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_CanAttack = True;
		Players In Slot(Slot Of(Event Player), Team 2).bot_AI_MoveCrouch_Enabled = True;
	}
}

rule("AI Subroutine: bot_Facing_Stop")
{
	event
	{
		Subroutine;
		bot_Facing_Stop;
	}

	actions
	{
		"Wait 4 frames before"
		Wait(4 / 60, Ignore Condition);
		Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
	}
}

rule("Player Mirror Mode On")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_MirrorMode_Enabled == True;
		Event Player.hud_SkyMenu_isOpen == False;
		Event Player.changingHero == False;
		Players In Slot(Slot Of(Event Player), Team 2).changingHero == False;
		Hero Of(Event Player) != Hero Of(Players In Slot(Slot Of(Event Player), Team 2));
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Hero Of(Players In Slot(Slot Of(Event Player), Team 2)));
		Wait(1 / 60, Ignore Condition);
		Stop Forcing Player To Be Hero(Event Player);
		Call Subroutine(player_SetDistances);
	}
}

rule("Mystery Mode AI Enable")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_MysteryMode_Enabled == True;
		Players In Slot(Slot Of(Event Player), Team 1).player_Difficulty >= 3;
		Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu_isOpen == False;
		Is Alive(Event Player) == True;
		Event Player.bot_BotResetComplete == True;
	}

	actions
	{
		Call Subroutine(bot_AIMode_Enable);
	}
}

rule("Subroutine: player_MysteryMode")
{
	event
	{
		Subroutine;
		player_MysteryMode;
	}

	actions
	{
		If(Event Player.player_MysteryMode_Enabled);
			Event Player.player_KillQuota = Global.globalKillQuota;
			Event Player.player_MysteryMode_Enabled = False;
			Small Message(Event Player, Custom String("Rapid Fire Mystery Mode Disabled"));
		Else;
			Event Player.player_KillQuota = 1;
			Event Player.player_CurrentHeroList = Randomized Array(Event Player.player_CurrentHeroList);
			Event Player.player_CurrentHero = 0;
			Event Player.player_CurrentHeroIncrement = 0;
			Call Subroutine(bot_SetHero);
			Event Player.player_MysteryMode_Enabled = True;
			Small Message(Event Player, Custom String("Rapid Fire Mystery Mode Enabled"));
		End;
	}
}

rule("Subroutine: player_1SecondCooldown")
{
	event
	{
		Subroutine;
		player_1SecondCooldown;
	}

	actions
	{
		If(Event Player.player_1SecondCooldown_Enabled);
			Event Player.player_1SecondCooldown_Enabled = False;
			Small Message(Event Player, Custom String("1 Second Cooldown Mode Disabled"));
		Else;
			Set Ultimate Charge(Event Player, 100);
			Event Player.player_1SecondCooldown_Enabled = True;
			Small Message(Event Player, Custom String("1 Second Cooldown Mode Enabled"));
		End;
	}
}

rule("Player 1 Second Cooldown Enemy Ult Charge")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Players In Slot(Slot Of(Event Player), Team 1).player_1SecondCooldown_Enabled == True;
		Is Alive(Event Player) == True;
		Ultimate Charge Percent(Event Player) >= 15;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Player 1 Second Cooldown Resets")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.player_1SecondCooldown_Enabled == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(1, Abort When False);
		If(Ability Cooldown(Event Player, Button(Primary Fire)) != 0);
			Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
		Else If(Ability Cooldown(Event Player, Button(Secondary Fire)) != 0 && Is Using Ability 1(Event Player) == False);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Else If(Ability Cooldown(Event Player, Button(Ability 1)) != 0 && Is Using Ability 1(Event Player) == False);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Else If(Ability Cooldown(Event Player, Button(Ability 2)) != 0 && Is Using Ability 2(Event Player) == False);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Else If(Ability Cooldown(Event Player, Button(Crouch)) != 0);
			Set Ability Cooldown(Event Player, Button(Crouch), 0);
		Else If(Ultimate Charge Percent(Event Player) < 100 && Is Using Ultimate(Event Player) == False);
			Set Ultimate Charge(Event Player, 100);
		End;
		Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
		Set Ammo(Event Player, 1, Max Ammo(Event Player, 1));
		Set Ability Charge(Event Player, Button(Ability 1), 3);
		Set Ability Charge(Event Player, Button(Ability 2), 3);
		Set Ability Resource(Event Player, Button(Secondary Fire), 100);
		Set Ability Resource(Event Player, Button(Jump), 100);
		Loop If Condition Is True;
	}
}
